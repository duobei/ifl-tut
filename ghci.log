Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (file src/Template/Mark5/Machine.hs changed)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[14 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[15 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[16 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[17 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[18 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[19 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[20 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[21 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[22 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 23 modules loaded.
>>> import Template.Mark5.Machine
>>> test "main = Cons (negate (2 + 3)) Nil"
   0) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   21    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  21: NSupercomb printList
               40: NAp   21    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [   1: NSupercomb main ]
      Depth 1
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NAp   48   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NSupercomb Cons
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  10) Heap [  18: NPrim Constr
               1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NPrim Constr
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NData 1 #47 #17 ]
      Depth 1
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  16) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   49   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,1)
      
  17) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
  18) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  22: NSupercomb printCons
               49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  19) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,3)
      
  20) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  21) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  22) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NAp #44 #45) ]
      Depth 1
      Output []
      Rule (2,13)
      
  23) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NAp #44 #45) ]
      Depth 2
      Output []
      Rule (2,1)
      
  24) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NAp   44   45 (NNum 3) ]
      Depth 1
      Output []
      Rule (2,9)
      
  25) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 2
      Output []
      Rule (2,1)
      
  26) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  24: NPrim +
               44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 3
      Output []
      Rule (2,1)
      
  27) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NNum 5 ]
      Depth 1
      Output []
      Rule (2,17)
      
  28) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NNum 5) ]
      Depth 1
      Output []
      Rule (2,7)
      
  29) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NNum 5) ]
      Depth 2
      Output []
      Rule (2,1)
      
  30) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NNum -5 ]
      Depth 1
      Output []
      Rule (2,5)
      
  31) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,7)
      
  32) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  33) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  34) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   21   17 (NSupercomb Nil) ]
      Depth 1
      Output [-5]
      Rule (2,12)
      
  35) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  21: NSupercomb printList
               51: NAp   21   17 (NSupercomb Nil) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  36) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  37) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  38) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  39) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  40) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NSupercomb Nil ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  41) Heap [  17: NPrim Constr
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NPrim Constr ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  42) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NData 0  ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  43) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  44) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  45) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  46) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  47) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NInd #38 ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  48) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  38: NPrim stop ]
      Depth 1
      Output [-5]
      Rule (2,4)
      
  49) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [ ]
      Depth 0
      Output [-5]
      Rule (2,11)
      

Total number of steps = 49
             Sc steps = 6
           Prim steps = 4
     Allocation count = 53
   Max depth of stack = 4>>> 
>>> test "main = Cons (negate (2 + 3)) Nil"
   0) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   21    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  21: NSupercomb printList
               40: NAp   21    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [   1: NSupercomb main ]
      Depth 1
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NAp   48   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NSupercomb Cons
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  10) Heap [  18: NPrim Constr
               1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NPrim Constr
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NData 1 #47 #17 ]
      Depth 1
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  16) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   49   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,1)
      
  17) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
  18) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  22: NSupercomb printCons
               49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  19) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,3)
      
  20) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  21) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  22) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NAp #44 #45) ]
      Depth 1
      Output []
      Rule (2,13)
      
  23) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NAp #44 #45) ]
      Depth 2
      Output []
      Rule (2,1)
      
  24) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NAp   44   45 (NNum 3) ]
      Depth 1
      Output []
      Rule (2,9)
      
  25) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 2
      Output []
      Rule (2,1)
      
  26) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  24: NPrim +
               44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 3
      Output []
      Rule (2,1)
      
  27) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NNum 5 ]
      Depth 1
      Output []
      Rule (2,17)
      
  28) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NNum 5) ]
      Depth 1
      Output []
      Rule (2,7)
      
  29) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NNum 5) ]
      Depth 2
      Output []
      Rule (2,1)
      
  30) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NNum -5 ]
      Depth 1
      Output []
      Rule (2,5)
      
  31) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,7)
      
  32) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  33) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  34) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   21   17 (NSupercomb Nil) ]
      Depth 1
      Output [-5]
      Rule (2,12)
      
  35) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  21: NSupercomb printList
               51: NAp   21   17 (NSupercomb Nil) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  36) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  37) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  38) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  39) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  40) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NSupercomb Nil ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  41) Heap [  17: NPrim Constr
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NPrim Constr ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  42) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NData 0  ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  43) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  44) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  45) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  46) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  47) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NInd #38 ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  48) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  38: NPrim stop ]
      Depth 1
      Output [-5]
      Rule (2,4)
      
  49) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [ ]
      Depth 0
      Output [-5]
      Rule (2,11)
      

Total number of steps = 49
             Sc steps = 6
           Prim steps = 4
     Allocation count = 53
   Max depth of stack = 4>>> 
>>> :e Template.Mark5.Machine
:l Template.Mark5.Machine
catn: Template.Mark5.Machine: openFile: does not exist (No such file or directory)
>>> 
<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap
        Iseq
        Language
        Parser
        Stack
        Template.Mark5.Node
        Template.Mark5.PPrint
        Template.Mark5.Primitive
        Template.Mark5.State
        Utils
[ 1 of 11] Compiling Parser           ( src/Parser.hs, interpreted )
[ 2 of 11] Compiling Stack            ( src/Stack.hs, interpreted )
[ 3 of 11] Compiling Utils            ( src/Utils.hs, interpreted )
[ 4 of 11] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 5 of 11] Compiling Language         ( src/Language.hs, interpreted )
[ 6 of 11] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 7 of 11] Compiling Heap             ( src/Heap.hs, interpreted )
[ 8 of 11] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[ 9 of 11] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[10 of 11] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[11 of 11] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 11 modules loaded.
>>> test "main = Cons (negate (2 + 3)) Nil"
   0) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   21    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  40: NAp #21 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  21: NSupercomb printList
               40: NAp   21    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NSupercomb main)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I
               1: NSupercomb main ]
      Stack [   1: NSupercomb main ]
      Depth 1
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NAp   48   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              18: NSupercomb Cons
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NSupercomb Cons
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  10) Heap [  18: NPrim Constr
               1: NAp #48 #17
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  18: NPrim Constr
               48: NAp   18   47 (NAp #23 #46)
                1: NAp   48   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [   1: NData 1 #47 #17 ]
      Depth 1
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   42   22 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              40: NAp #42 #22
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               41: NAp   36    1 (NData 1 #47 #17)
               42: NAp   41   38 (NPrim stop)
               40: NAp   42   22 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  16) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   49   17 (NSupercomb Nil) ]
      Depth 1
      Output []
      Rule (2,1)
      
  17) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 2
      Output []
      Rule (2,1)
      
  18) Heap [  40: NAp #49 #17
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  22: NSupercomb printCons
               49: NAp   22   47 (NAp #23 #46)
               40: NAp   49   17 (NSupercomb Nil) ]
      Depth 3
      Output []
      Rule (2,1)
      
  19) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,3)
      
  20) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  21) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NAp #23 #46)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  22) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NAp #44 #45) ]
      Depth 1
      Output []
      Rule (2,13)
      
  23) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NAp #44 #45) ]
      Depth 2
      Output []
      Rule (2,1)
      
  24) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NAp   44   45 (NNum 3) ]
      Depth 1
      Output []
      Rule (2,9)
      
  25) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 2
      Output []
      Rule (2,1)
      
  26) Heap [  40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              46: NAp #44 #45
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  24: NPrim +
               44: NAp   24   43 (NNum 2)
               46: NAp   44   45 (NNum 3) ]
      Depth 3
      Output []
      Rule (2,1)
      
  27) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  46: NNum 5 ]
      Depth 1
      Output []
      Rule (2,17)
      
  28) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NAp   23   46 (NNum 5) ]
      Depth 1
      Output []
      Rule (2,7)
      
  29) Heap [  46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              47: NAp #23 #46
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  23: NPrim negate
               47: NAp   23   46 (NNum 5) ]
      Depth 2
      Output []
      Rule (2,1)
      
  30) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  47: NNum -5 ]
      Depth 1
      Output []
      Rule (2,5)
      
  31) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  40: NAp   50   51 (NAp #21 #17) ]
      Depth 1
      Output []
      Rule (2,7)
      
  32) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 2
      Output []
      Rule (2,1)
      
  33) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  39: NPrim print
               50: NAp   39   47 (NNum -5)
               40: NAp   50   51 (NAp #21 #17) ]
      Depth 3
      Output []
      Rule (2,1)
      
  34) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   21   17 (NSupercomb Nil) ]
      Depth 1
      Output [-5]
      Rule (2,12)
      
  35) Heap [  47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              51: NAp #21 #17
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  21: NSupercomb printList
               51: NAp   21   17 (NSupercomb Nil) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  36) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  37) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  38) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  39) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NSupercomb Nil)
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  40) Heap [  51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              17: NSupercomb Nil
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NSupercomb Nil ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  41) Heap [  17: NPrim Constr
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NPrim Constr ]
      Depth 1
      Output [-5]
      Rule (2,3)
      
  42) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  17: NData 0  ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  43) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NAp   53   22 (NSupercomb printCons) ]
      Depth 1
      Output [-5]
      Rule (2,10)
      
  44) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 2
      Output [-5]
      Rule (2,1)
      
  45) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 3
      Output [-5]
      Rule (2,1)
      
  46) Heap [  17: NData 0 
              51: NAp #53 #22
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  36: NPrim caseList
               52: NAp   36   17 (NData 0 )
               53: NAp   52   38 (NPrim stop)
               51: NAp   53   22 (NSupercomb printCons) ]
      Depth 4
      Output [-5]
      Rule (2,1)
      
  47) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  51: NInd #38 ]
      Depth 1
      Output [-5]
      Rule (2,1)
      
  48) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [  38: NPrim stop ]
      Depth 1
      Output [-5]
      Rule (2,4)
      
  49) Heap [  51: NInd #38
              17: NData 0 
              53: NAp #52 #38
              52: NAp #36 #17
              47: NNum -5
              46: NNum 5
              40: NAp #50 #51
              50: NAp #39 #47
              49: NAp #22 #47
               1: NData 1 #47 #17
              18: NPrim Constr
              48: NAp #18 #47
              45: NNum 3
              44: NAp #24 #43
              43: NNum 2
              42: NAp #41 #38
              41: NAp #36 #1
              39: NPrim print
              38: NPrim stop
              37: NPrim abort
              36: NPrim caseList
              35: NPrim casePair
              34: NPrim if
              33: NPrim /=
              32: NPrim ==
              31: NPrim >=
              30: NPrim >
              29: NPrim <=
              28: NPrim <
              27: NPrim /
              26: NPrim *
              25: NPrim -
              24: NPrim +
              23: NPrim negate
              22: NSupercomb printCons
              21: NSupercomb printList
              20: NSupercomb tail
              19: NSupercomb head
              16: NSupercomb snd
              15: NSupercomb fst
              14: NSupercomb MkPair
              13: NSupercomb xor
              12: NSupercomb or
              11: NSupercomb and
              10: NSupercomb not
               9: NSupercomb True
               8: NSupercomb False
               7: NSupercomb twice
               6: NSupercomb compose
               5: NSupercomb S
               4: NSupercomb K1
               3: NSupercomb K
               2: NSupercomb I ]
      Stack [ ]
      Depth 0
      Output [-5]
      Rule (2,11)
      

Total number of steps = 49
             Sc steps = 6
           Prim steps = 4
     Allocation count = 53
   Max depth of stack = 4
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (file src/Template/Mark5a/PPrint.hs changed)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[14 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[15 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[16 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[17 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[18 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[19 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[20 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[21 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[22 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 23 modules loaded.
>>> import Template.Mark5a.Machine
>>> :i Double
type Double :: *
data Double
  = ghc-prim-0.8.0:GHC.Types.D# ghc-prim-0.8.0:GHC.Prim.Double#
  	-- Defined in ‘ghc-prim-0.8.0:GHC.Types’
instance Eq Double -- Defined in ‘ghc-prim-0.8.0:GHC.Classes’
instance Ord Double -- Defined in ‘ghc-prim-0.8.0:GHC.Classes’
instance Enum Double -- Defined in ‘GHC.Float’
instance Floating Double -- Defined in ‘GHC.Float’
instance Fractional Double -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
instance Real Double -- Defined in ‘GHC.Float’
instance RealFloat Double -- Defined in ‘GHC.Float’
instance RealFrac Double -- Defined in ‘GHC.Float’
instance Show Double -- Defined in ‘GHC.Float’
instance Read Double -- Defined in ‘GHC.Read’
>>> x = [1.797693e308 ..]
>>> x
[1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693e308,1.797693Interrupted.
>>> length it

<interactive>:5:8: error:
    • Variable not in scope: it :: t0 a0
    • Perhaps you meant ‘id’ (imported from Prelude)
>>> x = [1.797693e308 ..]
>>> length x
Interrupted.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (file src/Template/Mark5a/PPrint.hs changed)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[14 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[15 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[16 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[17 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[18 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[19 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[20 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[21 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[22 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
Ok, 23 modules loaded.
>>> x = [1.797693e307, 1.0e307 ..]
>>> x
[1.797693e307,1.0e307,2.0230699999999987e306,-5.953860000000001e306,-1.3930790000000004e307,-2.1907720000000006e307,-2.9884650000000006e307,-3.786158000000001e307,-4.583851000000001e307,-5.381544000000001e307,-6.179237000000002e307,-6.976930000000002e307,-7.774623000000001e307,-8.572316000000002e307,-9.370009e307,-1.0167702000000002e308,-1.0965395e308,-1.1763088e308,-1.2560781000000001e308,-1.3358474e308,-1.4156167000000002e308,-1.4953860000000001e308,-1.5751553000000002e308,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-InfInterrupted.
>>> succ (1/0)
Infinity
>>> length $ show $ succ (10^99)
100
>>> length $ show $ succ (10^49)
50
>>> length $ show $ (maxBound :: Word)
20
>>> succ (10^30)
1000000000000000000000000000001
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.1 (lib) (ephemeral targets)
Preprocessing library for ifl-tut-0.2.8.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 23] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 23] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 23] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 23] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 23] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 23] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 23] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 23] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 23] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 23] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 23] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 23] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 23] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[14 of 23] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[15 of 23] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[16 of 23] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[17 of 23] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[18 of 23] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[19 of 23] Compiling Template.Mark5   ( src/Template/Mark5.hs, interpreted )
[20 of 23] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[21 of 23] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[22 of 23] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[23 of 23] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 23 modules loaded.
>>> import Template.Mark5b.State
>>> import Template.Mark5b.Machine
>>> :t testt

<interactive>:1:1: error:
    • Variable not in scope: testt
    • Perhaps you meant ‘test’ (imported from Template.Mark5b.Machine)
>>> :t test
test :: String -> IO ()
>>> test "main = Cons e Nil ; e = (1 + 2) * (3 + 5)"
   0) Heap [  41: NAp #22 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  41: NAp   22    1 (NSupercomb main) ]
      Depth 1
      Output []
      Rule (2,0)
      
   1) Heap [  41: NAp #22 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  22: NSupercomb printList
               41: NAp   22    1 (NSupercomb main) ]
      Depth 2
      Output []
      Rule (2,1)
      
   2) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  41: NAp   43   23 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,3)
      
   3) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   4) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  42: NAp   37    1 (NSupercomb main)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   5) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [  37: NPrim caseList
               42: NAp   37    1 (NSupercomb main)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
   6) Heap [  41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e
               1: NSupercomb main ]
      Stack [   1: NSupercomb main
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
   7) Heap [   1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [   1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,3)
      
   8) Heap [   1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  44: NAp   19    2 (NSupercomb e)
                1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
   9) Heap [   1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              19: NSupercomb Cons
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  19: NSupercomb Cons
               44: NAp   19    2 (NSupercomb e)
                1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
  10) Heap [  19: NPrim Constr
               1: NAp #44 #18
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  19: NPrim Constr
               44: NAp   19    2 (NSupercomb e)
                1: NAp   44   18 (NSupercomb Nil)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,3)
      
  11) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [   1: NData 1 #2 #18 #23
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,10)
      
  12) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  41: NAp   43   23 (NSupercomb printCons) ]
      Depth 1
      Output []
      Rule (2,10)
      
  13) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 2
      Output []
      Rule (2,1)
      
  14) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  42: NAp   37    1 (NData 1 #2 #18 #23)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 3
      Output []
      Rule (2,1)
      
  15) Heap [   1: NData 1 #2 #18 #23
              19: NPrim Constr
              44: NAp #19 #2
              41: NAp #43 #23
              43: NAp #42 #39
              42: NAp #37 #1
              40: NPrim print
              39: NPrim stop
              38: NPrim abort
              37: NPrim caseList
              36: NPrim casePair
              35: NPrim if
              34: NPrim /=
              33: NPrim ==
              32: NPrim >=
              31: NPrim >
              30: NPrim <=
              29: NPrim <
              28: NPrim /
              27: NPrim *
              26: NPrim -
              25: NPrim +
              24: NPrim negate
              23: NSupercomb printCons
              22: NSupercomb printList
              21: NSupercomb tail
              20: NSupercomb head
              18: NSupercomb Nil
              17: NSupercomb snd
              16: NSupercomb fst
              15: NSupercomb MkPair
              14: NSupercomb xor
              13: NSupercomb or
              12: NSupercomb and
              11: NSupercomb not
              10: NSupercomb True
               9: NSupercomb False
               8: NSupercomb twice
               7: NSupercomb compose
               6: NSupercomb S
               5: NSupercomb K1
               4: NSupercomb K
               3: NSupercomb I
               2: NSupercomb e ]
      Stack [  37: NPrim caseList
               42: NAp   37    1 (NData 1 #2 #18 #23)
               43: NAp   42   39 (NPrim stop)
               41: NAp   43   23 (NSupercomb printCons) ]
      Depth 4
      Output []
      Rule (2,1)
      
*** Exception: src/Template/Mark5b/State.hs:(188,32)-(191,79): Non-exhaustive patterns in case

>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.2.2 (lib) (first run)
Configuring library for ifl-tut-0.2.8.2.2..
Preprocessing library for ifl-tut-0.2.8.2.2..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 22] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 22] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 22] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 22] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 22] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 22] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 22] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 22] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 22] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )

src/Template/Mark5b/Machine.hs:134:5: error:
    parse error on input ‘|’
    |
134 |     | otherwise
    |     ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | テスト：01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )

src/Template/Mark5b/Machine.hs:43:33: error:
    Not in scope: ‘control’
   |
43 | setControl ctrl state = state { control = ctrl }
   |                                 ^^^^^^^

src/Template/Mark5b/Machine.hs:49:7: error: Not in scope: ‘control’
   |
49 |     { control = []
   |       ^^^^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.2.2 (lib) (first run)
Preprocessing library for ifl-tut-0.2.8.2.2..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 22] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 22] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 22] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 22] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 22] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 22] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 22] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 22] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 22] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )

src/Template/Mark5b/Machine.hs:43:33: error:
    Not in scope: ‘control’
   |
43 | setControl ctrl state = state { control = ctrl }
   |                                 ^^^^^^^

src/Template/Mark5b/Machine.hs:49:7: error: Not in scope: ‘control’
   |
49 |     { control = []
   |       ^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | テスト：01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[10 of 22] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted ) [Template.Mark5b.State changed]
[11 of 22] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[12 of 22] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[13 of 22] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[14 of 22] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[15 of 22] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[16 of 22] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[17 of 22] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[18 of 22] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[19 of 22] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[20 of 22] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[21 of 22] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[22 of 22] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 22 modules loaded.
>>> mapAccumL (\ js i -> (tail js, map (i *) js)) [1 .. 9] 

<interactive>:2:1: error:
    Variable not in scope:
      mapAccumL :: ([b0] -> b0 -> ([b0], [b0])) -> [a0] -> t
>>> import Data.List
>>> mapAccumL (\ js i -> (tail js, map (i *) js)) [1 .. 9] 

<interactive>:4:1: error:
    • No instance for (Show ([Integer] -> ([Integer], [[Integer]])))
        arising from a use of ‘Text.Show.Unicode.uprint’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command:
        Text.Show.Unicode.uprint it
>>> mapAccumL (\ js i -> (tail js, map (i *) js)) [1 .. 9] [1 .. 9]
([],[[1,2,3,4,5,6,7,8,9],[4,6,8,10,12,14,16,18],[9,12,15,18,21,24,27],[16,20,24,28,32,36],[25,30,35,40,45],[36,42,48,54],[49,56,63],[64,72],[81]])
>>> map (\ i -> flip map [1 .. 9] (* i)) [1 .. 9]
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> map (flip map [1..9] . (*)) [1..9]
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> rjustify = reverse . take 3 . foldr (:) (repeat ' ')
>>> rjustify (show 1)
"  1"
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (concatMap (map (reverse . take 3 . foldr (:) (repeat ' ') . show)) it))
  1
  2
  3
  4
  5
  6
  7
  8
  9
  2
  4
  6
  8
 01
 21
 41
 61
 81
  3
  6
  9
 21
 51
 81
 12
 42
 72
  4
  8
 21
 61
 02
 42
 82
 23
 63
  5
 01
 51
 02
 52
 03
 53
 04
 54
  6
 21
 81
 42
 03
 63
 24
 84
 45
  7
 41
 12
 82
 53
 24
 94
 65
 36
  8
 61
 42
 23
 04
 84
 65
 46
 27
  9
 81
 72
 63
 54
 45
 36
 27
 18
>>> rjustify (show 72)
" 27"
>>> 
>>> 
>>> 
>>> 
>>> 
>>> putStr (unlines (map (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show)) it))

<interactive>:18:85: error:
    • Couldn't match type ‘Char’ with ‘t0 a0’
      Expected: [t0 a0]
        Actual: [Char]
    • In the second argument of ‘map’, namely ‘it’
      In the first argument of ‘unlines’, namely
        ‘(map
            (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show)) it)’
      In the first argument of ‘putStr’, namely
        ‘(unlines
            (map
               (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show))
               it))’
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (map (concatMap (reverse . take 3 . foldr (:) (repeat ' ') . show)) it))
  1  2  3  4  5  6  7  8  9
  2  4  6  8 01 21 41 61 81
  3  6  9 21 51 81 12 42 72
  4  8 21 61 02 42 82 23 63
  5 01 51 02 52 03 53 04 54
  6 21 81 42 03 63 24 84 45
  7 41 12 82 53 24 94 65 36
  8 61 42 23 04 84 65 46 27
  9 81 72 63 54 45 36 27 18
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (map (concatMap (reverse . take 3 . foldl (flip (:)) (repeat ' ') . show)) it))
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> [ [ i * j | i <- [1..9]] | j <- [1 .. 9]] 
[[1,2,3,4,5,6,7,8,9],[2,4,6,8,10,12,14,16,18],[3,6,9,12,15,18,21,24,27],[4,8,12,16,20,24,28,32,36],[5,10,15,20,25,30,35,40,45],[6,12,18,24,30,36,42,48,54],[7,14,21,28,35,42,49,56,63],[8,16,24,32,40,48,56,64,72],[9,18,27,36,45,54,63,72,81]]
>>> putStr (unlines (map (>>= (reverse . take 3 . foldl (flip (:)) (repeat ' ') . show)) it))
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> [ [ revreverse $ take 3 $ foldl (flip (:)) (repeat ' ') $ show     $ i * j | i <- [1..9]] | j <- [1 .. 9] ] 

<interactive>:25:5: error:
    • Variable not in scope: revreverse :: [Char] -> a
    • Perhaps you meant ‘reverse’ (imported from Data.List)
>>> 
>>> 
>>> 
>>> 
>>> 
>>> [concat  [ reverse $ take 3 $ foldl (flip (:)) (repeat ' ') $ show     $ i * j | i <- [1..9]] | j <- [1 .. 9] ] 
["  1  2  3  4  5  6  7  8  9","  2  4  6  8 10 12 14 16 18","  3  6  9 12 15 18 21 24 27","  4  8 12 16 20 24 28 32 36","  5 10 15 20 25 30 35 40 45","  6 12 18 24 30 36 42 48 54","  7 14 21 28 35 42 49 56 63","  8 16 24 32 40 48 56 64 72","  9 18 27 36 45 54 63 72 81"]
>>> :t for

<interactive>:1:1: error:
    • Variable not in scope: for
    • Perhaps you meant ‘or’ (imported from Data.List)
>>> :i &

<interactive>:1:1: error: Not in scope: ‘&’
>>> :e
No files to edit.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.8.2.2 (lib) (first run)
Preprocessing library for ifl-tut-0.2.8.2.2..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 22] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 22] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 22] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 22] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 22] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 22] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 22] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 22] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:328:18: error:
    Ambiguous occurrence ‘rjustify’
    It could refer to
       either ‘Utils.rjustify’,
              imported from ‘Utils’ at src/Template/Mark5b/State.hs:11:1-12
              (and originally defined at src/Utils.hs:16:1-8)
           or ‘Template.Mark5b.State.rjustify’,
              defined at src/Template/Mark5b/State.hs:322:1
    |
328 |           $ kuku rjustify
    |                  ^^^^^^^^
Failed, 8 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | テスト：01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs
[ 9 of 22] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:328:18: error:
    Ambiguous occurrence ‘rjustify’
    It could refer to
       either ‘Utils.rjustify’,
              imported from ‘Utils’ at src/Template/Mark5b/State.hs:11:1-12
              (and originally defined at src/Utils.hs:16:1-8)
           or ‘Template.Mark5b.State.rjustify’,
              defined at src/Template/Mark5b/State.hs:322:1
    |
328 |           $ kuku rjustify
    |                  ^^^^^^^^
Failed, 8 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 125  buildInitialHeap = let ?sz = defaultHeapSize in
 126      mapAccumL allocateSc hInitial
 127  
 128  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 129  allocateSc heap scDefn = case scDefn of
 130      (name, args, body) -> (heap', (name, addr))
 131          where
 132              (heap', addr) = hAlloc heap (NSupercomb name args body)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdminTotalSteps $ step state
 141  
 142  tiFinal :: TiState -> Bool
 143  tiFinal state
 144      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 145      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 146      | otherwise                    = False
 147      where
 148          (soleAddr, _) = pop state.stack
 149  
 150  isDataNode :: Node -> Bool
 151  isDataNode node = case node of
 152      NNum _ -> True
 153      _      -> False
 154  
 155  doAdminTotalSteps :: TiState -> TiState
 156  doAdminTotalSteps = applyToStats incTotalSteps
 157  
 158  doAdminScSteps :: TiState -> TiState
 159  doAdminScSteps = applyToStats incScSteps
 160  
 161  doAdminPrimSteps :: TiState -> TiState
 162  doAdminPrimSteps = applyToStats incPrimSteps
 163  
 164  step :: TiState -> TiState
 165  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 166             $ state
 167  
 168  numStep :: Int -> TiState -> TiState
 169  numStep n = error "numStep: Number applied as a function"
 170  
 171  apStep :: Addr -> Addr -> TiState -> TiState
 172  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 173  
 174  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 175  scStep name args body state
 176      | state.stack.curDepth < n' 
 177          = error "scStep: too few arguments given"
 178      | otherwise
 179          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 180      where
 181          stack' = push resultAddr (discard n' state.stack)
 182          (heap', resultAddr) = instantiate body state.heap env
 183          env = argBindings ++ state.globals
 184          argBindings = zip args (getargs state.heap state.stack)
 185          n' = succ (length args)
 186  
 187  getargs :: TiHeap -> TiStack -> [Addr]
 188  getargs heap stack = case pop stack of
 189      (sc, stack') -> map getarg stack'.stkItems
 190          where
 191              getarg addr = arg
 192                  where
 193                      NAp fun arg = hLookup heap addr
 194  
 195  {- | Instantiation -}
 196  
 197  instantiate :: CoreExpr
 198              -> TiHeap
 199              -> Assoc Name Addr
 200              -> (TiHeap, Addr)
 201  instantiate expr heap env = dispatchCoreExpr
 202      (instantiateVar heap env)
 203      (instantiateNum heap env)
 204      (instantiateConstr heap env)
 205      (instantiateAp heap env)
 206      (instantiateLet heap env)
 207      (instantiateCase heap env)
 208      (instantiateLam heap env)
 209      expr
 210  
 211  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 212  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 213  
 214  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 215  instantiateNum heap env num = hAlloc heap (NNum num)
 216  
 217  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 218  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 219  
 220  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 221  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 222      where
 223          (heap1, a1) = instantiate a heap  env
 224          (heap2, a2) = instantiate b heap1 env
 225  
 226  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 228  
 229  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 230  instantiateCase heap env expr alters = error "Cannot instatiate case"
 231  
 232  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 234  
 235  {- | Formatting Results -}
 236  
 237  showResults :: [TiState] -> String
 238  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 239  
 240  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 241  mapoid (f, g) (x:xs) = case xs of
 242      [] -> f x : [g x]
 243      _  -> f x : mapoid (f,g) xs
 244  
 245  showState :: TiState -> IseqRep
 246  showState state = iConcat
 247      [ showHeap state.heap, iNewline
 248      , showStack state.heap state.stack, iNewline
 249      , showRuleId state.ruleid, iNewline
 250      ]
 251  
 252  showHeap :: TiHeap -> IseqRep
 253  showHeap heap = iConcat
 254      [ iStr "Heap ["
 255      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 256      , iStr " ]"
 257      ]
 258  
 259  showHeapItem :: (Addr, Node) -> IseqRep
 260  showHeapItem (addr, node) = iConcat
 261              [ showFWAddr addr, iStr ": "
 262              , showNode node
 263              ]
 264  
 265  showAddr :: Addr -> IseqRep
 266  showAddr addr = iStr ('#' : show addr)
 267  
 268  showFWAddr :: Addr -> IseqRep
 269  showFWAddr addr = iStr (rjustify 4 (show addr))
 270  
 271  showNode :: Node -> IseqRep
 272  showNode node = dispatchNode
 273      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 274      (\ name args body -> iStr ("NSupercomb " ++ name))
 275      (\ n -> iStr "NNum " `iAppend` iNum n)
 276      node
 277  
 278  showStack :: TiHeap -> TiStack -> IseqRep
 279  showStack heap stack = iConcat
 280      [ iStr "Stack ["
 281      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 282      , iStr " ]"
 283      ]
 284      where
 285          showStackItem addr = iConcat
 286              [ showFWAddr addr, iStr ": "
 287              , showStkNode heap (hLookup heap addr)
 288              ]
 289  
 290  showStkNode :: TiHeap -> Node -> IseqRep
 291  showStkNode heap node = dispatchNode
 292      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 293                                    , iStr " ", showFWAddr argAddr, iStr " ("
 294                                    , showNode (hLookup heap argAddr), iStr ")" ])
 295      (\ _ _ _ -> showNode node)
 296      (\ _ -> showNode node)
 297      node
 298  
 299  showRuleId :: TiRuleId -> IseqRep
 300  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 301  
 302  showStats :: TiState -> IseqRep
 303  showStats state = iConcat
 304      [ iNewline, iStr "Total number of steps = "
 305      , iNum state.stats.totalSteps
 306      , iNewline, iStr "             Sc steps = "
 307      , iNum state.stats.scSteps
 308      , iNewline, iStr "           Prim steps = "
 309      , iNum state.stats.primSteps
 310      , iNewline, iStr "          Delta steps = "
 311      , iNum state.stats.deltaSteps
 312      , iNewline, iStr "     Allocation count = "
 313      , iNum state.heap.maxAllocs
 314      , iNewline, iStr "   Max depth of stack = "
 315      , iNum state.stack.maxDepth
 316      ]
 317  
 318  {- | Testing -}
 319  
 320  test :: String -> IO ()
 321  test = putStr . run
 322  
 323  {- | テスト：01 
 324  -}
 325  prog01 :: String
 326  prog01 = unlines
 327      ["main = S K K 3"]
 328  
 329  istate01 :: TiState
 330  istate01 = compile $ parse prog01
 331  
 332  iheap01 :: TiHeap
 333  iheap01 = istate01.heap
 334  
 335  iitems01 :: Assoc Addr Node
 336  iitems01 = iheap01.assocs

src/Template/Mark5b/State.hs:11:21: error:
    parse error on input ‘rjustify’
   |
11 | import Utils hiding rjustify
   |                     ^^^^^^^^
Failed, no modules loaded.
>>> :e
No files to edit.
>>> import Template.Mark5b.State

<no location info>: error:
    Could not load module ‘Template.Mark5b.State’
    It is a member of the hidden package ‘ifl-tut-0.2.8.2.1’.
    Perhaps you need to add ‘ifl-tut’ to the build-depends in your .cabal file.
    It is a member of the hidden package ‘ifl-tut-0.2.8.2’.
    Perhaps you need to add ‘ifl-tut’ to the build-depends in your .cabal file.
    It is a member of the hidden package ‘ifl-tut-0.2.8.2’.
    Perhaps you need to add ‘ifl-tut’ to the build-depends in your .cabal file.
    It is a member of the hidden package ‘ifl-tut-0.2.8.2’.
    Perhaps you need to add ‘ifl-tut’ to the build-depends in your .cabal file.
    It is a member of the hidden package ‘ifl-tut-0.2.8.2’.
    Perhaps you need to add ‘ifl-tut’ to the build-depends in your .cabal file.
>>> kukuPrint

<interactive>:5:1: error: Variable not in scope: kukuPrint
>>> :e Template.Mark5a.State
:l Template.Mark5a.State
catn: Template.Mark5a.State: openFile: does not exist (No such file or directory)
>>> 
<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[1 of 7] Compiling Parser           ( src/Parser.hs, interpreted )
[2 of 7] Compiling Stack            ( src/Stack.hs, interpreted )
[3 of 7] Compiling Utils            ( src/Utils.hs, interpreted )
[4 of 7] Compiling Iseq             ( src/Iseq.hs, interpreted )
[5 of 7] Compiling Language         ( src/Language.hs, interpreted )
[6 of 7] Compiling Heap             ( src/Heap.hs, interpreted )
[7 of 7] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
Ok, 7 modules loaded.
>>> kukuPrint

<interactive>:8:1: error: Variable not in scope: kukuPrint
>>> printKuku

<interactive>:9:1: error: Variable not in scope: printKuku
>>> :e src/Template/Mark5b/State.hs
:l src/Template/Mark5b/State.hs 
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take 3 . foldl (flip (:)) (repeat ' ') . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr 
 326            $ unlines 
 327            $ map concat
 328            $ kuku rjustify

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
Ok, 7 modules loaded.
>>> 
<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[1 of 7] Compiling Parser           ( src/Parser.hs, interpreted )
[2 of 7] Compiling Stack            ( src/Stack.hs, interpreted )
[3 of 7] Compiling Utils            ( src/Utils.hs, interpreted )
[4 of 7] Compiling Iseq             ( src/Iseq.hs, interpreted )
[5 of 7] Compiling Language         ( src/Language.hs, interpreted )
[6 of 7] Compiling Heap             ( src/Heap.hs, interpreted )
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:328:18: error:
    • Couldn't match type: a0 -> String
                     with: [Char]
      Expected: Int -> [Char]
        Actual: Int -> a0 -> String
    • Probable cause: ‘rjustify’ is applied to too few arguments
      In the first argument of ‘kuku’, namely ‘rjustify’
      In the second argument of ‘($)’, namely ‘kuku rjustify’
      In the second argument of ‘($)’, namely
        ‘map concat $ kuku rjustify’
    |
328 |           $ kuku rjustify
    |                  ^^^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take 3 . foldl (flip (:)) (repeat ' ') . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr 
 326            $ unlines 
 327            $ map concat
 328            $ kuku (rjustify 3)

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take 3 . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map concat $ kuku (rjustify 3)

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: (Int -> a) -> [[a]]
 319  kuku f = [ [ f (i * j) | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map concat $ kuku (rjustify 3)

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: [[a]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:319:43: error:
    • No instance for (Enum a)
        arising from the arithmetic sequence ‘1 .. 9’
      Possible fix:
        add (Enum a) to the context of
          the type signature for:
            kuku :: forall a. [[a]]
    • In the expression: [1 .. 9]
      In a stmt of a list comprehension: i <- [1 .. 9]
      In the expression: [[i * j | j <- [1 .. 9]] | i <- [1 .. 9]]
    |
319 | kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
    |                                           ^^^^^^^^

src/Template/Mark5b/State.hs:319:44: error:
    • No instance for (Num a) arising from the literal ‘1’
      Possible fix:
        add (Num a) to the context of
          the type signature for:
            kuku :: forall a. [[a]]
    • In the expression: 1
      In the expression: [1 .. 9]
      In a stmt of a list comprehension: i <- [1 .. 9]
    |
319 | kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
    |                                            ^

src/Template/Mark5b/State.hs:325:41: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘rjustify’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance (Show a, Show b) => Show (Either a b)
          -- Defined in ‘Data.Either’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Associativity -- Defined at src/Language.hs:208:38
        ...plus 28 others
        ...plus 53 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: rjustify 3
      In the first argument of ‘map’, namely ‘(>>= rjustify 3)’
      In the second argument of ‘(.)’, namely ‘map (>>= rjustify 3)’
    |
325 | printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
    |                                         ^^^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> printKuku
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> import Data.Function
>>> :i &
(&) :: a -> (a -> b) -> b 	-- Defined in ‘Data.Function’
infixl 1 &
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint
 330      = flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 333          ; putStrLn ""
 334          }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:21: error:
    Variable not in scope: (&) :: t0 -> (a0 -> String) -> t1
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                     ^

src/Template/Mark5b/State.hs:332:28: error:
    Variable not in scope:
      (&) :: t1 -> ([a1] -> [a1]) -> ([Char] -> [Char]) -> t2
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                            ^

src/Template/Mark5b/State.hs:332:56: error:
    Variable not in scope: (&) :: t2 -> ([a2] -> [a2]) -> t3
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                        ^

src/Template/Mark5b/State.hs:332:65: error:
    Variable not in scope: (&) :: t3 -> ([a3] -> [a3]) -> t4
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                                 ^

src/Template/Mark5b/State.hs:332:75: error:
    Variable not in scope: (&) :: t4 -> (String -> IO ()) -> IO b0
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                                           ^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = do
 330      { let { (&) = flip ($); infixl & 1 }
 331      ; flip mapM_ [1 .. 9] $ \ i -> do
 332          { flip mapM_ [1 .. 9] $ \ j -> do
 333              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 334          ; putStrLn ""
 335          }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:330:38: error:
    parse error on input ‘1’
    |
330 |     { let { (&) = flip ($); infixl & 1 }
    |                                      ^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = do
 330      { let { (&) = flip ($); infixl 1 & }
 331      ; flip mapM_ [1 .. 9] $ \ i -> do
 332          { flip mapM_ [1 .. 9] $ \ j -> do
 333              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 334          ; putStrLn ""
 335          }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:336:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = let { (&) = flip ($); infixl 1 & } in do
 330      { flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
 333          ; putStrLn ""
 334          }
 335      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:30: error:
    • Couldn't match type: [Char]
                     with: IO () -> IO b0
      Expected: String -> IO () -> IO b0
        Actual: [Char] -> [Char]
    • In the second argument of ‘(&)’, namely ‘reverse’
      In the first argument of ‘($)’, namely ‘i * j & show & reverse’
      In a stmt of a 'do' block:
        i * j & show & reverse
          $ (++ repeat ' ') & take 3 & reverse & putStr
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                              ^^^^^^^

src/Template/Mark5b/State.hs:332:58: error:
    • Couldn't match type: [Char]
                     with: [Char] -> [Char]
      Expected: ([Char] -> [Char]) -> [Char]
        Actual: [Char] -> [Char]
    • In the second argument of ‘(&)’, namely ‘take 3’
      In the first argument of ‘(&)’, namely ‘(++ repeat ' ') & take 3’
      In the first argument of ‘(&)’, namely
        ‘(++ repeat ' ') & take 3 & reverse’
    |
332 |             { i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse & putStr }
    |                                                          ^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = let { (&) = flip ($); infixl 1 & } in do
 330      { flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { let rep = i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
 333              ; putStr rep 
 334              }
 335          ; putStrLn ""
 336          }
 337      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:40: error:
    • Couldn't match type: [Char]
                     with: [a0] -> b
      Expected: String -> [a0] -> b
        Actual: [Char] -> [Char]
    • In the second argument of ‘(&)’, namely ‘reverse’
      In the first argument of ‘($)’, namely ‘i * j & show & reverse’
      In the expression:
        i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
    • Relevant bindings include
        rep :: b (bound at src/Template/Mark5b/State.hs:332:19)
    |
332 |             { let rep = i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
    |                                        ^^^^^^^

src/Template/Mark5b/State.hs:332:68: error:
    • Couldn't match type: [a0]
                     with: [Char] -> [Char]
      Expected: ([Char] -> [Char]) -> [a0]
        Actual: [a0] -> [a0]
    • In the second argument of ‘(&)’, namely ‘take 3’
      In the first argument of ‘(&)’, namely ‘(++ repeat ' ') & take 3’
      In the second argument of ‘($)’, namely
        ‘(++ repeat ' ') & take 3 & reverse’
    |
332 |             { let rep = i * j & show & reverse $ (++ repeat ' ') & take 3 & reverse
    |                                                                    ^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  
  13  data TiState
  14      = TiState
  15      { control :: TiControl
  16      , output  :: TiOutput
  17      , stack   :: TiStack
  18      , dump    :: TiDump
  19      , heap    :: TiHeap
  20      , globals :: TiGlobals
  21      , stats   :: TiStats
  22      , ruleid  :: TiRuleId
  23      }
  24  
  25  type TiControl = [String]
  26  
  27  type TiOutput  = [Int]
  28  
  29  type TiStack   = Stack Addr
  30  
  31  type TiDump    = Stack Int
  32  initialDump :: TiDump
  33  initialDump = emptyStack
  34  
  35  type TiHeap    = Heap Node
  36  
  37  type TiGlobals = Assoc Name Addr
  38  
  39  data TiStats 
  40      = TiStats
  41      { totalSteps :: Int
  42      , scSteps    :: Int
  43      , primSteps  :: Int
  44      }
  45      deriving Show
  46  
  47  initialStats :: TiStats
  48  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  49  
  50  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  51  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  52  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  53  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  54  
  55  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  56  applyToStats f state = state { stats = f state.stats }
  57  
  58  type TiRuleId = Int
  59  
  60  setRuleId :: TiRuleId -> TiState -> TiState
  61  setRuleId r state = state { ruleid = r }
  62  
  63  tiFinal :: TiState -> Bool
  64  tiFinal state = isEmptyStack state.stack
  65  
  66  -- | Primitive
  67  
  68  type Primitive = TiState -> TiState
  69  
  70  primitives :: Assoc Name Primitive
  71  primitives = [ ("negate", primNeg)
  72               , ("+", primArith (+)), ("-", primArith (-))
  73               , ("*", primArith (+)), ("/", primArith div)
  74               , ("<", primComp (<)), ("<=", primComp (<=))
  75               , (">", primComp (>)), (">=", primComp (>=))
  76               , ("==", primComp (==)), ("/=", primComp (/=))
  77               , ("if", primIf)
  78               , ("casePair", primCasePair)
  79               , ("caseList", primCaseList)
  80               , ("abort", primAbort)
  81               , ("stop", primStop)
  82               , ("print", primPrint)
  83               ]
  84  
  85  primNeg :: TiState -> TiState
  86  primNeg state
  87      | length args < 1          = error "primNeg: wrong number of args"
  88      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  89          (stack2, dump2) -> setRuleId 9
  90                           $ state { stack = stack2, dump = dump2 }
  91      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  92                                 $ state { stack = stack1, heap = heap1 }
  93      where
  94          args      = take 1 $ getargs state.heap state.stack
  95          [argAddr] = args
  96          argNode   = hLookup state.heap argAddr
  97          NNum argValue = argNode
  98          (_, stack1) = pop state.stack
  99          (root, _)   = pop stack1
 100          heap1 = hUpdate state.heap root (NNum (negate argValue))
 101  
 102  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 103  primArith op = primDyadic op'
 104      where
 105          op' (NNum m) (NNum n) = NNum (m `op` n)
 106  
 107  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 108  primComp op = primDyadic op'
 109      where
 110          op' (NNum m) (NNum n)
 111              | m `op` n  = NData 1 []
 112              | otherwise = NData 0 []
 113  
 114  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 115  primDyadic op state 
 116      | length args < 2 = error "primDyadic: wrong number of args"
 117      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 118          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 119      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 120          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 121      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 122                                  $ state { stack = stack1, heap = heap1 }
 123      where
 124          args = take 2 $ getargs state.heap state.stack
 125          [arg1Addr, arg2Addr] = args
 126          [arg1Node, arg2Node] = map (hLookup state.heap) args
 127          stack1 = discard 2 state.stack
 128          (root, _) = pop stack1
 129          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 130  
 131  primConstr :: Tag -> Arity -> TiState -> TiState
 132  primConstr tag arity state
 133      | length args < arity = error "primConstr: wrong number of args"
 134      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 135      where
 136          args = take arity $ getargs state.heap state.stack
 137          stack1 = discard arity state.stack
 138          (root,_) = pop stack1
 139          heap1 = hUpdate state.heap root (NData tag args)
 140  
 141  primIf :: TiState -> TiState
 142  primIf state
 143      | length args < 3 = error "primIf: wrong number of args"
 144      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 145          (stack2, dump2) -> setRuleId 19
 146                           $ state { stack = stack2, dump = dump2 }
 147      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 148      where
 149          args = take 3 $ getargs state.heap state.stack
 150          [arg1Addr, arg2Addr, arg3Addr] = args
 151          arg1Node = hLookup state.heap arg1Addr
 152          stack1 = discard 3 state.stack 
 153          (root, _) = pop stack1
 154          result = case arg1Node of
 155              NData 0 [] -> arg3Addr
 156              _          -> arg2Addr
 157          heap1 = hUpdate state.heap root (NInd result)
 158  
 159  primCasePair :: TiState -> TiState
 160  primCasePair state
 161      | length args < 2 = error "primCasePair: wrong number of args"
 162      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 163          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 164      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 165      where
 166          args = take 2 $ getargs state.heap state.stack
 167          [arg1Addr, arg2Addr] = args
 168          arg1Node = hLookup state.heap arg1Addr
 169          stack1 = discard 2 state.stack
 170          (root, _) = pop stack1
 171          heap1 = case arg1Node of
 172              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 173                  where
 174                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 175  
 176  primCaseList :: TiState -> TiState
 177  primCaseList state
 178      | length args < 3 = error "primCaseList: wrong number of args"
 179      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 180          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 181      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 182      where
 183          args = take 3 $ getargs state.heap state.stack
 184          [arg1Addr, arg2Addr, arg3Addr] = args
 185          arg1Node = hLookup state.heap arg1Addr
 186          stack1 = discard 3 state.stack
 187          (root, _) = pop stack1
 188          heap1 = case arg1Node of
 189              NData tag cmpnts
 190                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 191                  | otherwise -> case cmpnts of
 192                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 193                          where
 194                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 195                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 196              _ -> error "not NData node"
 197  
 198  primAbort :: TiState -> TiState
 199  primAbort = error "Program abort!"
 200  
 201  primStop :: TiState -> TiState
 202  primStop state 
 203      | not (isEmptyStack state.dump) 
 204          = error "primStop: dump is not empty"
 205      | otherwise
 206          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 207  
 208  primPrint :: TiState -> TiState
 209  primPrint state
 210      | argsLen < 2 = error "primPrint: wrong number of args"
 211      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 212      | otherwise = case arg1Node of
 213          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 214                                            , stack = push arg2Addr (emptyStack' state.stack)
 215                                            }
 216          NData _ _ -> error "primPrint: not a number"
 217          _         -> case saveAndPush arg1Addr stack1 state.dump of
 218              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 219      where
 220          args = take 2 $ getargs state.heap state.stack
 221          argsLen = length args
 222          [arg1Addr, arg2Addr] = args
 223          arg1Node = hLookup state.heap arg1Addr
 224          NNum arg1Value = arg1Node
 225          stack1 = discard argsLen state.stack
 226  
 227  -- | Node
 228  
 229  data Node
 230      = NAp Addr Addr
 231      | NSupercomb Name [Name] CoreExpr
 232      | NNum Int
 233      | NInd Addr
 234      | NPrim Name Primitive
 235      | NData Tag [Addr]
 236  
 237  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 238               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 239               -> (Int -> a)                        -- ^ NInt
 240               -> (Addr -> a)                       -- ^ NInd
 241               -> (Name -> Primitive -> a)          -- ^ NPrim
 242               -> (Tag -> [Addr] -> a)              -- ^ NData
 243               -> Node -> a
 244  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 245      NAp a b                -> nap a b
 246      NSupercomb f args body -> nsupercomb f args body
 247      NNum n                 -> nnum n
 248      NInd a                 -> nind a
 249      NPrim name prim        -> nprim name prim
 250      NData tag contents     -> ndata tag contents
 251  
 252  isDataNode :: Node -> Bool
 253  isDataNode node = case node of
 254      NNum _    -> True
 255      NData _ _ -> True
 256      _         -> False
 257  
 258  doAdminTotalSteps :: TiState -> TiState
 259  doAdminTotalSteps = applyToStats incTotalSteps
 260  
 261  doAdminScSteps :: TiState -> TiState
 262  doAdminScSteps = applyToStats incScSteps
 263  
 264  doAdminPrimSteps :: TiState -> TiState
 265  doAdminPrimSteps = applyToStats incPrimSteps
 266  
 267  getargs :: TiHeap -> TiStack -> [Addr]
 268  getargs heap stack = case pop stack of
 269      (sc, stack1) -> map getarg stack1.stkItems
 270          where
 271              getarg addr = case hLookup heap addr of
 272                  NAp _ arg -> arg
 273                  _         -> error "getarg: not application node"
 274  
 275  --
 276  emptyStack' :: TiStack -> TiStack
 277  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 278  
 279  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 280  saveAndPush addr stack dump
 281      = (push addr stack, push stack.curDepth dump)
 282  
 283  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 284  restore stack dump
 285      | isEmptyStack dump = error "restore: dump is empty"
 286      | otherwise         = case pop dump of
 287          (sp, dump') 
 288              -> ( discard (stack.curDepth - sp) stack, dump' )
 289  
 290  --
 291  ruleTable :: [(TiRuleId, String)]
 292  ruleTable 
 293      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 294        , (2, "Rule (2.2): Perform a supercombinator reduction")
 295        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 296        , (4, "Rule (2.4): Update the indirection node to immediate node")
 297        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 298        , (6, "Rule (2.6): For operand evaluation of negation")
 299        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 300        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 301        , (9, "Rule (2.9): For operand evaluation of negation")
 302        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 303        , (11, "Rule (2.11): For `NPrim Stop`")
 304        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 305        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 306        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 307        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 308        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 309        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 310        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 311        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 312        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 313        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 314        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 315        ]
 316  
 317  {-
 318  kuku :: [[Int]]
 319  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 320  
 321  rjustify :: (Show a) => Int -> a -> String
 322  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 323  
 324  printKuku :: IO ()
 325  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 326  -}
 327  
 328  kukuPrint :: IO ()
 329  kukuPrint = let { (&) = flip ($); infixl 1 & } in do
 330      { flip mapM_ [1 .. 9] $ \ i -> do
 331          { flip mapM_ [1 .. 9] $ \ j -> do
 332              { let str = i * j & show & reverse $ (++ repeat ' ')
 333              ; let rep = str $ take 3
 334              ; putStr rep 
 335              }
 336          ; putStrLn ""
 337          }
 338      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:332:40: error:
    • Couldn't match type: [Char]
                     with: ([Char] -> [Char]) -> b
      Expected: String -> ([Char] -> [Char]) -> b
        Actual: [Char] -> [Char]
    • In the second argument of ‘(&)’, namely ‘reverse’
      In the first argument of ‘($)’, namely ‘i * j & show & reverse’
      In the expression: i * j & show & reverse $ (++ repeat ' ')
    • Relevant bindings include
        str :: b (bound at src/Template/Mark5b/State.hs:332:19)
    |
332 |             { let str = i * j & show & reverse $ (++ repeat ' ')
    |                                        ^^^^^^^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  import Data.Function
  13  
  14  data TiState
  15      = TiState
  16      { control :: TiControl
  17      , output  :: TiOutput
  18      , stack   :: TiStack
  19      , dump    :: TiDump
  20      , heap    :: TiHeap
  21      , globals :: TiGlobals
  22      , stats   :: TiStats
  23      , ruleid  :: TiRuleId
  24      }
  25  
  26  type TiControl = [String]
  27  
  28  type TiOutput  = [Int]
  29  
  30  type TiStack   = Stack Addr
  31  
  32  type TiDump    = Stack Int
  33  initialDump :: TiDump
  34  initialDump = emptyStack
  35  
  36  type TiHeap    = Heap Node
  37  
  38  type TiGlobals = Assoc Name Addr
  39  
  40  data TiStats 
  41      = TiStats
  42      { totalSteps :: Int
  43      , scSteps    :: Int
  44      , primSteps  :: Int
  45      }
  46      deriving Show
  47  
  48  initialStats :: TiStats
  49  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  50  
  51  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  52  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  53  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  54  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  55  
  56  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  57  applyToStats f state = state { stats = f state.stats }
  58  
  59  type TiRuleId = Int
  60  
  61  setRuleId :: TiRuleId -> TiState -> TiState
  62  setRuleId r state = state { ruleid = r }
  63  
  64  tiFinal :: TiState -> Bool
  65  tiFinal state = isEmptyStack state.stack
  66  
  67  -- | Primitive
  68  
  69  type Primitive = TiState -> TiState
  70  
  71  primitives :: Assoc Name Primitive
  72  primitives = [ ("negate", primNeg)
  73               , ("+", primArith (+)), ("-", primArith (-))
  74               , ("*", primArith (+)), ("/", primArith div)
  75               , ("<", primComp (<)), ("<=", primComp (<=))
  76               , (">", primComp (>)), (">=", primComp (>=))
  77               , ("==", primComp (==)), ("/=", primComp (/=))
  78               , ("if", primIf)
  79               , ("casePair", primCasePair)
  80               , ("caseList", primCaseList)
  81               , ("abort", primAbort)
  82               , ("stop", primStop)
  83               , ("print", primPrint)
  84               ]
  85  
  86  primNeg :: TiState -> TiState
  87  primNeg state
  88      | length args < 1          = error "primNeg: wrong number of args"
  89      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  90          (stack2, dump2) -> setRuleId 9
  91                           $ state { stack = stack2, dump = dump2 }
  92      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  93                                 $ state { stack = stack1, heap = heap1 }
  94      where
  95          args      = take 1 $ getargs state.heap state.stack
  96          [argAddr] = args
  97          argNode   = hLookup state.heap argAddr
  98          NNum argValue = argNode
  99          (_, stack1) = pop state.stack
 100          (root, _)   = pop stack1
 101          heap1 = hUpdate state.heap root (NNum (negate argValue))
 102  
 103  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 104  primArith op = primDyadic op'
 105      where
 106          op' (NNum m) (NNum n) = NNum (m `op` n)
 107  
 108  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 109  primComp op = primDyadic op'
 110      where
 111          op' (NNum m) (NNum n)
 112              | m `op` n  = NData 1 []
 113              | otherwise = NData 0 []
 114  
 115  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 116  primDyadic op state 
 117      | length args < 2 = error "primDyadic: wrong number of args"
 118      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 119          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 120      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 121          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 122      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 123                                  $ state { stack = stack1, heap = heap1 }
 124      where
 125          args = take 2 $ getargs state.heap state.stack
 126          [arg1Addr, arg2Addr] = args
 127          [arg1Node, arg2Node] = map (hLookup state.heap) args
 128          stack1 = discard 2 state.stack
 129          (root, _) = pop stack1
 130          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 131  
 132  primConstr :: Tag -> Arity -> TiState -> TiState
 133  primConstr tag arity state
 134      | length args < arity = error "primConstr: wrong number of args"
 135      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 136      where
 137          args = take arity $ getargs state.heap state.stack
 138          stack1 = discard arity state.stack
 139          (root,_) = pop stack1
 140          heap1 = hUpdate state.heap root (NData tag args)
 141  
 142  primIf :: TiState -> TiState
 143  primIf state
 144      | length args < 3 = error "primIf: wrong number of args"
 145      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 146          (stack2, dump2) -> setRuleId 19
 147                           $ state { stack = stack2, dump = dump2 }
 148      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 149      where
 150          args = take 3 $ getargs state.heap state.stack
 151          [arg1Addr, arg2Addr, arg3Addr] = args
 152          arg1Node = hLookup state.heap arg1Addr
 153          stack1 = discard 3 state.stack 
 154          (root, _) = pop stack1
 155          result = case arg1Node of
 156              NData 0 [] -> arg3Addr
 157              _          -> arg2Addr
 158          heap1 = hUpdate state.heap root (NInd result)
 159  
 160  primCasePair :: TiState -> TiState
 161  primCasePair state
 162      | length args < 2 = error "primCasePair: wrong number of args"
 163      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 164          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 165      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 166      where
 167          args = take 2 $ getargs state.heap state.stack
 168          [arg1Addr, arg2Addr] = args
 169          arg1Node = hLookup state.heap arg1Addr
 170          stack1 = discard 2 state.stack
 171          (root, _) = pop stack1
 172          heap1 = case arg1Node of
 173              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 174                  where
 175                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 176  
 177  primCaseList :: TiState -> TiState
 178  primCaseList state
 179      | length args < 3 = error "primCaseList: wrong number of args"
 180      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 181          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 182      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 183      where
 184          args = take 3 $ getargs state.heap state.stack
 185          [arg1Addr, arg2Addr, arg3Addr] = args
 186          arg1Node = hLookup state.heap arg1Addr
 187          stack1 = discard 3 state.stack
 188          (root, _) = pop stack1
 189          heap1 = case arg1Node of
 190              NData tag cmpnts
 191                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 192                  | otherwise -> case cmpnts of
 193                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 194                          where
 195                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 196                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 197              _ -> error "not NData node"
 198  
 199  primAbort :: TiState -> TiState
 200  primAbort = error "Program abort!"
 201  
 202  primStop :: TiState -> TiState
 203  primStop state 
 204      | not (isEmptyStack state.dump) 
 205          = error "primStop: dump is not empty"
 206      | otherwise
 207          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 208  
 209  primPrint :: TiState -> TiState
 210  primPrint state
 211      | argsLen < 2 = error "primPrint: wrong number of args"
 212      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 213      | otherwise = case arg1Node of
 214          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 215                                            , stack = push arg2Addr (emptyStack' state.stack)
 216                                            }
 217          NData _ _ -> error "primPrint: not a number"
 218          _         -> case saveAndPush arg1Addr stack1 state.dump of
 219              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 220      where
 221          args = take 2 $ getargs state.heap state.stack
 222          argsLen = length args
 223          [arg1Addr, arg2Addr] = args
 224          arg1Node = hLookup state.heap arg1Addr
 225          NNum arg1Value = arg1Node
 226          stack1 = discard argsLen state.stack
 227  
 228  -- | Node
 229  
 230  data Node
 231      = NAp Addr Addr
 232      | NSupercomb Name [Name] CoreExpr
 233      | NNum Int
 234      | NInd Addr
 235      | NPrim Name Primitive
 236      | NData Tag [Addr]
 237  
 238  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 239               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 240               -> (Int -> a)                        -- ^ NInt
 241               -> (Addr -> a)                       -- ^ NInd
 242               -> (Name -> Primitive -> a)          -- ^ NPrim
 243               -> (Tag -> [Addr] -> a)              -- ^ NData
 244               -> Node -> a
 245  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 246      NAp a b                -> nap a b
 247      NSupercomb f args body -> nsupercomb f args body
 248      NNum n                 -> nnum n
 249      NInd a                 -> nind a
 250      NPrim name prim        -> nprim name prim
 251      NData tag contents     -> ndata tag contents
 252  
 253  isDataNode :: Node -> Bool
 254  isDataNode node = case node of
 255      NNum _    -> True
 256      NData _ _ -> True
 257      _         -> False
 258  
 259  doAdminTotalSteps :: TiState -> TiState
 260  doAdminTotalSteps = applyToStats incTotalSteps
 261  
 262  doAdminScSteps :: TiState -> TiState
 263  doAdminScSteps = applyToStats incScSteps
 264  
 265  doAdminPrimSteps :: TiState -> TiState
 266  doAdminPrimSteps = applyToStats incPrimSteps
 267  
 268  getargs :: TiHeap -> TiStack -> [Addr]
 269  getargs heap stack = case pop stack of
 270      (sc, stack1) -> map getarg stack1.stkItems
 271          where
 272              getarg addr = case hLookup heap addr of
 273                  NAp _ arg -> arg
 274                  _         -> error "getarg: not application node"
 275  
 276  --
 277  emptyStack' :: TiStack -> TiStack
 278  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 279  
 280  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 281  saveAndPush addr stack dump
 282      = (push addr stack, push stack.curDepth dump)
 283  
 284  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 285  restore stack dump
 286      | isEmptyStack dump = error "restore: dump is empty"
 287      | otherwise         = case pop dump of
 288          (sp, dump') 
 289              -> ( discard (stack.curDepth - sp) stack, dump' )
 290  
 291  --
 292  ruleTable :: [(TiRuleId, String)]
 293  ruleTable 
 294      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 295        , (2, "Rule (2.2): Perform a supercombinator reduction")
 296        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 297        , (4, "Rule (2.4): Update the indirection node to immediate node")
 298        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 299        , (6, "Rule (2.6): For operand evaluation of negation")
 300        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 301        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 302        , (9, "Rule (2.9): For operand evaluation of negation")
 303        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 304        , (11, "Rule (2.11): For `NPrim Stop`")
 305        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 306        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 307        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 308        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 309        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 310        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 311        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 312        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 313        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 314        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 315        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 316        ]
 317  
 318  {-
 319  kuku :: [[Int]]
 320  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 321  
 322  rjustify :: (Show a) => Int -> a -> String
 323  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 324  
 325  printKuku :: IO ()
 326  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 327  -}
 328  
 329  kukuPrint :: IO ()
 330  kukuPrint = flip mapM_ [1 .. 9] $ \ i -> do
 331                  { flip mapM_ [1 .. 9] $ \ j -> do
 332                      { let rep = i * j & show
 333                      ; putStrLn rep
 334                      }
 335          ; putStrLn ""
 336          }
 337      }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )

src/Template/Mark5b/State.hs:337:5: error: parse error on input ‘}’
    |
337 |     }
    |     ^
Failed, six modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  import Data.Function
  13  
  14  data TiState
  15      = TiState
  16      { control :: TiControl
  17      , output  :: TiOutput
  18      , stack   :: TiStack
  19      , dump    :: TiDump
  20      , heap    :: TiHeap
  21      , globals :: TiGlobals
  22      , stats   :: TiStats
  23      , ruleid  :: TiRuleId
  24      }
  25  
  26  type TiControl = [String]
  27  
  28  type TiOutput  = [Int]
  29  
  30  type TiStack   = Stack Addr
  31  
  32  type TiDump    = Stack Int
  33  initialDump :: TiDump
  34  initialDump = emptyStack
  35  
  36  type TiHeap    = Heap Node
  37  
  38  type TiGlobals = Assoc Name Addr
  39  
  40  data TiStats 
  41      = TiStats
  42      { totalSteps :: Int
  43      , scSteps    :: Int
  44      , primSteps  :: Int
  45      }
  46      deriving Show
  47  
  48  initialStats :: TiStats
  49  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  50  
  51  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  52  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  53  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  54  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  55  
  56  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  57  applyToStats f state = state { stats = f state.stats }
  58  
  59  type TiRuleId = Int
  60  
  61  setRuleId :: TiRuleId -> TiState -> TiState
  62  setRuleId r state = state { ruleid = r }
  63  
  64  tiFinal :: TiState -> Bool
  65  tiFinal state = isEmptyStack state.stack
  66  
  67  -- | Primitive
  68  
  69  type Primitive = TiState -> TiState
  70  
  71  primitives :: Assoc Name Primitive
  72  primitives = [ ("negate", primNeg)
  73               , ("+", primArith (+)), ("-", primArith (-))
  74               , ("*", primArith (+)), ("/", primArith div)
  75               , ("<", primComp (<)), ("<=", primComp (<=))
  76               , (">", primComp (>)), (">=", primComp (>=))
  77               , ("==", primComp (==)), ("/=", primComp (/=))
  78               , ("if", primIf)
  79               , ("casePair", primCasePair)
  80               , ("caseList", primCaseList)
  81               , ("abort", primAbort)
  82               , ("stop", primStop)
  83               , ("print", primPrint)
  84               ]
  85  
  86  primNeg :: TiState -> TiState
  87  primNeg state
  88      | length args < 1          = error "primNeg: wrong number of args"
  89      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  90          (stack2, dump2) -> setRuleId 9
  91                           $ state { stack = stack2, dump = dump2 }
  92      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  93                                 $ state { stack = stack1, heap = heap1 }
  94      where
  95          args      = take 1 $ getargs state.heap state.stack
  96          [argAddr] = args
  97          argNode   = hLookup state.heap argAddr
  98          NNum argValue = argNode
  99          (_, stack1) = pop state.stack
 100          (root, _)   = pop stack1
 101          heap1 = hUpdate state.heap root (NNum (negate argValue))
 102  
 103  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 104  primArith op = primDyadic op'
 105      where
 106          op' (NNum m) (NNum n) = NNum (m `op` n)
 107  
 108  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 109  primComp op = primDyadic op'
 110      where
 111          op' (NNum m) (NNum n)
 112              | m `op` n  = NData 1 []
 113              | otherwise = NData 0 []
 114  
 115  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 116  primDyadic op state 
 117      | length args < 2 = error "primDyadic: wrong number of args"
 118      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 119          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 120      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 121          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 122      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 123                                  $ state { stack = stack1, heap = heap1 }
 124      where
 125          args = take 2 $ getargs state.heap state.stack
 126          [arg1Addr, arg2Addr] = args
 127          [arg1Node, arg2Node] = map (hLookup state.heap) args
 128          stack1 = discard 2 state.stack
 129          (root, _) = pop stack1
 130          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 131  
 132  primConstr :: Tag -> Arity -> TiState -> TiState
 133  primConstr tag arity state
 134      | length args < arity = error "primConstr: wrong number of args"
 135      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 136      where
 137          args = take arity $ getargs state.heap state.stack
 138          stack1 = discard arity state.stack
 139          (root,_) = pop stack1
 140          heap1 = hUpdate state.heap root (NData tag args)
 141  
 142  primIf :: TiState -> TiState
 143  primIf state
 144      | length args < 3 = error "primIf: wrong number of args"
 145      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 146          (stack2, dump2) -> setRuleId 19
 147                           $ state { stack = stack2, dump = dump2 }
 148      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 149      where
 150          args = take 3 $ getargs state.heap state.stack
 151          [arg1Addr, arg2Addr, arg3Addr] = args
 152          arg1Node = hLookup state.heap arg1Addr
 153          stack1 = discard 3 state.stack 
 154          (root, _) = pop stack1
 155          result = case arg1Node of
 156              NData 0 [] -> arg3Addr
 157              _          -> arg2Addr
 158          heap1 = hUpdate state.heap root (NInd result)
 159  
 160  primCasePair :: TiState -> TiState
 161  primCasePair state
 162      | length args < 2 = error "primCasePair: wrong number of args"
 163      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 164          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 165      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 166      where
 167          args = take 2 $ getargs state.heap state.stack
 168          [arg1Addr, arg2Addr] = args
 169          arg1Node = hLookup state.heap arg1Addr
 170          stack1 = discard 2 state.stack
 171          (root, _) = pop stack1
 172          heap1 = case arg1Node of
 173              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 174                  where
 175                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 176  
 177  primCaseList :: TiState -> TiState
 178  primCaseList state
 179      | length args < 3 = error "primCaseList: wrong number of args"
 180      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 181          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 182      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 183      where
 184          args = take 3 $ getargs state.heap state.stack
 185          [arg1Addr, arg2Addr, arg3Addr] = args
 186          arg1Node = hLookup state.heap arg1Addr
 187          stack1 = discard 3 state.stack
 188          (root, _) = pop stack1
 189          heap1 = case arg1Node of
 190              NData tag cmpnts
 191                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 192                  | otherwise -> case cmpnts of
 193                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 194                          where
 195                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 196                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 197              _ -> error "not NData node"
 198  
 199  primAbort :: TiState -> TiState
 200  primAbort = error "Program abort!"
 201  
 202  primStop :: TiState -> TiState
 203  primStop state 
 204      | not (isEmptyStack state.dump) 
 205          = error "primStop: dump is not empty"
 206      | otherwise
 207          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 208  
 209  primPrint :: TiState -> TiState
 210  primPrint state
 211      | argsLen < 2 = error "primPrint: wrong number of args"
 212      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 213      | otherwise = case arg1Node of
 214          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 215                                            , stack = push arg2Addr (emptyStack' state.stack)
 216                                            }
 217          NData _ _ -> error "primPrint: not a number"
 218          _         -> case saveAndPush arg1Addr stack1 state.dump of
 219              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 220      where
 221          args = take 2 $ getargs state.heap state.stack
 222          argsLen = length args
 223          [arg1Addr, arg2Addr] = args
 224          arg1Node = hLookup state.heap arg1Addr
 225          NNum arg1Value = arg1Node
 226          stack1 = discard argsLen state.stack
 227  
 228  -- | Node
 229  
 230  data Node
 231      = NAp Addr Addr
 232      | NSupercomb Name [Name] CoreExpr
 233      | NNum Int
 234      | NInd Addr
 235      | NPrim Name Primitive
 236      | NData Tag [Addr]
 237  
 238  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 239               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 240               -> (Int -> a)                        -- ^ NInt
 241               -> (Addr -> a)                       -- ^ NInd
 242               -> (Name -> Primitive -> a)          -- ^ NPrim
 243               -> (Tag -> [Addr] -> a)              -- ^ NData
 244               -> Node -> a
 245  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 246      NAp a b                -> nap a b
 247      NSupercomb f args body -> nsupercomb f args body
 248      NNum n                 -> nnum n
 249      NInd a                 -> nind a
 250      NPrim name prim        -> nprim name prim
 251      NData tag contents     -> ndata tag contents
 252  
 253  isDataNode :: Node -> Bool
 254  isDataNode node = case node of
 255      NNum _    -> True
 256      NData _ _ -> True
 257      _         -> False
 258  
 259  doAdminTotalSteps :: TiState -> TiState
 260  doAdminTotalSteps = applyToStats incTotalSteps
 261  
 262  doAdminScSteps :: TiState -> TiState
 263  doAdminScSteps = applyToStats incScSteps
 264  
 265  doAdminPrimSteps :: TiState -> TiState
 266  doAdminPrimSteps = applyToStats incPrimSteps
 267  
 268  getargs :: TiHeap -> TiStack -> [Addr]
 269  getargs heap stack = case pop stack of
 270      (sc, stack1) -> map getarg stack1.stkItems
 271          where
 272              getarg addr = case hLookup heap addr of
 273                  NAp _ arg -> arg
 274                  _         -> error "getarg: not application node"
 275  
 276  --
 277  emptyStack' :: TiStack -> TiStack
 278  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 279  
 280  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 281  saveAndPush addr stack dump
 282      = (push addr stack, push stack.curDepth dump)
 283  
 284  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 285  restore stack dump
 286      | isEmptyStack dump = error "restore: dump is empty"
 287      | otherwise         = case pop dump of
 288          (sp, dump') 
 289              -> ( discard (stack.curDepth - sp) stack, dump' )
 290  
 291  --
 292  ruleTable :: [(TiRuleId, String)]
 293  ruleTable 
 294      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 295        , (2, "Rule (2.2): Perform a supercombinator reduction")
 296        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 297        , (4, "Rule (2.4): Update the indirection node to immediate node")
 298        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 299        , (6, "Rule (2.6): For operand evaluation of negation")
 300        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 301        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 302        , (9, "Rule (2.9): For operand evaluation of negation")
 303        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 304        , (11, "Rule (2.11): For `NPrim Stop`")
 305        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 306        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 307        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 308        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 309        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 310        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 311        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 312        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 313        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 314        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 315        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 316        ]
 317  
 318  {-
 319  kuku :: [[Int]]
 320  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 321  
 322  rjustify :: (Show a) => Int -> a -> String
 323  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 324  
 325  printKuku :: IO ()
 326  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 327  -}
 328  
 329  kukuPrint :: IO ()
 330  kukuPrint = flip mapM_ [1 .. 9] $ \ i -> do
 331                  { flip mapM_ [1 .. 9] $ \ j -> do
 332                      { let rep = i * j & show
 333                      ; putStrLn rep
 334                      }
 335                  ; putStrLn ""
 336                  }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5b.State
   6      where
   7  
   8  import Language
   9  import Heap
  10  import Stack
  11  import Utils hiding (rjustify)
  12  import Data.Function
  13  import Control.Monad
  14  
  15  data TiState
  16      = TiState
  17      { control :: TiControl
  18      , output  :: TiOutput
  19      , stack   :: TiStack
  20      , dump    :: TiDump
  21      , heap    :: TiHeap
  22      , globals :: TiGlobals
  23      , stats   :: TiStats
  24      , ruleid  :: TiRuleId
  25      }
  26  
  27  type TiControl = [String]
  28  
  29  type TiOutput  = [Int]
  30  
  31  type TiStack   = Stack Addr
  32  
  33  type TiDump    = Stack Int
  34  initialDump :: TiDump
  35  initialDump = emptyStack
  36  
  37  type TiHeap    = Heap Node
  38  
  39  type TiGlobals = Assoc Name Addr
  40  
  41  data TiStats 
  42      = TiStats
  43      { totalSteps :: Int
  44      , scSteps    :: Int
  45      , primSteps  :: Int
  46      }
  47      deriving Show
  48  
  49  initialStats :: TiStats
  50  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0 }
  51  
  52  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  53  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  54  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  55  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  56  
  57  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  58  applyToStats f state = state { stats = f state.stats }
  59  
  60  type TiRuleId = Int
  61  
  62  setRuleId :: TiRuleId -> TiState -> TiState
  63  setRuleId r state = state { ruleid = r }
  64  
  65  tiFinal :: TiState -> Bool
  66  tiFinal state = isEmptyStack state.stack
  67  
  68  -- | Primitive
  69  
  70  type Primitive = TiState -> TiState
  71  
  72  primitives :: Assoc Name Primitive
  73  primitives = [ ("negate", primNeg)
  74               , ("+", primArith (+)), ("-", primArith (-))
  75               , ("*", primArith (+)), ("/", primArith div)
  76               , ("<", primComp (<)), ("<=", primComp (<=))
  77               , (">", primComp (>)), (">=", primComp (>=))
  78               , ("==", primComp (==)), ("/=", primComp (/=))
  79               , ("if", primIf)
  80               , ("casePair", primCasePair)
  81               , ("caseList", primCaseList)
  82               , ("abort", primAbort)
  83               , ("stop", primStop)
  84               , ("print", primPrint)
  85               ]
  86  
  87  primNeg :: TiState -> TiState
  88  primNeg state
  89      | length args < 1          = error "primNeg: wrong number of args"
  90      | not (isDataNode argNode) = case saveAndPush argAddr stack1 state.dump of
  91          (stack2, dump2) -> setRuleId 9
  92                           $ state { stack = stack2, dump = dump2 }
  93      | otherwise                = doAdminPrimSteps $ setRuleId 5 
  94                                 $ state { stack = stack1, heap = heap1 }
  95      where
  96          args      = take 1 $ getargs state.heap state.stack
  97          [argAddr] = args
  98          argNode   = hLookup state.heap argAddr
  99          NNum argValue = argNode
 100          (_, stack1) = pop state.stack
 101          (root, _)   = pop stack1
 102          heap1 = hUpdate state.heap root (NNum (negate argValue))
 103  
 104  primArith :: (Int -> Int -> Int) -> TiState -> TiState
 105  primArith op = primDyadic op'
 106      where
 107          op' (NNum m) (NNum n) = NNum (m `op` n)
 108  
 109  primComp :: (Int -> Int -> Bool) -> TiState -> TiState
 110  primComp op = primDyadic op'
 111      where
 112          op' (NNum m) (NNum n)
 113              | m `op` n  = NData 1 []
 114              | otherwise = NData 0 []
 115  
 116  primDyadic :: (Node -> Node -> Node) -> TiState -> TiState
 117  primDyadic op state 
 118      | length args < 2 = error "primDyadic: wrong number of args"
 119      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 120          (stack2, dump2) -> setRuleId 16 $ state { stack = stack2, dump = dump2 }
 121      | not (isDataNode arg2Node) = case saveAndPush arg2Addr stack1 state.dump of
 122          (stack3, dump3) -> setRuleId 17 $ state { stack = stack3, dump = dump3 }
 123      | otherwise                 = doAdminPrimSteps $ setRuleId 15
 124                                  $ state { stack = stack1, heap = heap1 }
 125      where
 126          args = take 2 $ getargs state.heap state.stack
 127          [arg1Addr, arg2Addr] = args
 128          [arg1Node, arg2Node] = map (hLookup state.heap) args
 129          stack1 = discard 2 state.stack
 130          (root, _) = pop stack1
 131          heap1 = hUpdate state.heap root (op arg1Node arg2Node)
 132  
 133  primConstr :: Tag -> Arity -> TiState -> TiState
 134  primConstr tag arity state
 135      | length args < arity = error "primConstr: wrong number of args"
 136      | otherwise           = setRuleId 10 $ state { stack = stack1, heap = heap1 }
 137      where
 138          args = take arity $ getargs state.heap state.stack
 139          stack1 = discard arity state.stack
 140          (root,_) = pop stack1
 141          heap1 = hUpdate state.heap root (NData tag args)
 142  
 143  primIf :: TiState -> TiState
 144  primIf state
 145      | length args < 3 = error "primIf: wrong number of args"
 146      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 147          (stack2, dump2) -> setRuleId 19
 148                           $ state { stack = stack2, dump = dump2 }
 149      | otherwise = doAdminPrimSteps $ setRuleId 18 $ state { stack = stack1, heap = heap1}
 150      where
 151          args = take 3 $ getargs state.heap state.stack
 152          [arg1Addr, arg2Addr, arg3Addr] = args
 153          arg1Node = hLookup state.heap arg1Addr
 154          stack1 = discard 3 state.stack 
 155          (root, _) = pop stack1
 156          result = case arg1Node of
 157              NData 0 [] -> arg3Addr
 158              _          -> arg2Addr
 159          heap1 = hUpdate state.heap root (NInd result)
 160  
 161  primCasePair :: TiState -> TiState
 162  primCasePair state
 163      | length args < 2 = error "primCasePair: wrong number of args"
 164      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 165          (stack2, dump2) -> setRuleId 21 $ state { stack = stack2, dump = dump2 }
 166      | otherwise = doAdminPrimSteps $ setRuleId 20 $ state { stack = stack1, heap = heap1 }
 167      where
 168          args = take 2 $ getargs state.heap state.stack
 169          [arg1Addr, arg2Addr] = args
 170          arg1Node = hLookup state.heap arg1Addr
 171          stack1 = discard 2 state.stack
 172          (root, _) = pop stack1
 173          heap1 = case arg1Node of
 174              NData tag [ft,sd] -> hUpdate heap2 root (NAp addr sd)
 175                  where
 176                      (heap2 ,addr) = hAlloc state.heap (NAp arg2Addr ft)
 177  
 178  primCaseList :: TiState -> TiState
 179  primCaseList state
 180      | length args < 3 = error "primCaseList: wrong number of args"
 181      | not (isDataNode arg1Node) = case saveAndPush arg1Addr stack1 state.dump of
 182          (stack2, dump2) -> setRuleId 23 $ state { stack = stack2, dump = dump2 }
 183      | otherwise = doAdminPrimSteps $ setRuleId 22 $ state { stack = stack1, heap = heap1 }
 184      where
 185          args = take 3 $ getargs state.heap state.stack
 186          [arg1Addr, arg2Addr, arg3Addr] = args
 187          arg1Node = hLookup state.heap arg1Addr
 188          stack1 = discard 3 state.stack
 189          (root, _) = pop stack1
 190          heap1 = case arg1Node of
 191              NData tag cmpnts
 192                  | tag == 0 {- [] -} -> hUpdate state.heap root (NInd arg2Addr)
 193                  | otherwise -> case cmpnts of
 194                      [hd, tl]  -> hUpdate heap2 root (NAp addr tl)
 195                          where
 196                              (heap2, addr) = hAlloc state.heap (NAp arg3Addr hd)
 197                      _         -> error ("primCaseList: not a cons " ++ show cmpnts)
 198              _ -> error "not NData node"
 199  
 200  primAbort :: TiState -> TiState
 201  primAbort = error "Program abort!"
 202  
 203  primStop :: TiState -> TiState
 204  primStop state 
 205      | not (isEmptyStack state.dump) 
 206          = error "primStop: dump is not empty"
 207      | otherwise
 208          = setRuleId 11 $ state { stack = emptyStack' state.stack }
 209  
 210  primPrint :: TiState -> TiState
 211  primPrint state
 212      | argsLen < 2 = error "primPrint: wrong number of args"
 213      | not (isEmptyStack state.dump) = error "primPrint: dump is not empty"
 214      | otherwise = case arg1Node of
 215          NNum m    -> setRuleId 12 $ state { output = state.output ++ [m]
 216                                            , stack = push arg2Addr (emptyStack' state.stack)
 217                                            }
 218          NData _ _ -> error "primPrint: not a number"
 219          _         -> case saveAndPush arg1Addr stack1 state.dump of
 220              (stack2, dump2) -> setRuleId 13 $ state { stack = stack2, dump = dump2 }
 221      where
 222          args = take 2 $ getargs state.heap state.stack
 223          argsLen = length args
 224          [arg1Addr, arg2Addr] = args
 225          arg1Node = hLookup state.heap arg1Addr
 226          NNum arg1Value = arg1Node
 227          stack1 = discard argsLen state.stack
 228  
 229  -- | Node
 230  
 231  data Node
 232      = NAp Addr Addr
 233      | NSupercomb Name [Name] CoreExpr
 234      | NNum Int
 235      | NInd Addr
 236      | NPrim Name Primitive
 237      | NData Tag [Addr]
 238  
 239  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
 240               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
 241               -> (Int -> a)                        -- ^ NInt
 242               -> (Addr -> a)                       -- ^ NInd
 243               -> (Name -> Primitive -> a)          -- ^ NPrim
 244               -> (Tag -> [Addr] -> a)              -- ^ NData
 245               -> Node -> a
 246  dispatchNode nap nsupercomb nnum nind nprim ndata node = case node of
 247      NAp a b                -> nap a b
 248      NSupercomb f args body -> nsupercomb f args body
 249      NNum n                 -> nnum n
 250      NInd a                 -> nind a
 251      NPrim name prim        -> nprim name prim
 252      NData tag contents     -> ndata tag contents
 253  
 254  isDataNode :: Node -> Bool
 255  isDataNode node = case node of
 256      NNum _    -> True
 257      NData _ _ -> True
 258      _         -> False
 259  
 260  doAdminTotalSteps :: TiState -> TiState
 261  doAdminTotalSteps = applyToStats incTotalSteps
 262  
 263  doAdminScSteps :: TiState -> TiState
 264  doAdminScSteps = applyToStats incScSteps
 265  
 266  doAdminPrimSteps :: TiState -> TiState
 267  doAdminPrimSteps = applyToStats incPrimSteps
 268  
 269  getargs :: TiHeap -> TiStack -> [Addr]
 270  getargs heap stack = case pop stack of
 271      (sc, stack1) -> map getarg stack1.stkItems
 272          where
 273              getarg addr = case hLookup heap addr of
 274                  NAp _ arg -> arg
 275                  _         -> error "getarg: not application node"
 276  
 277  --
 278  emptyStack' :: TiStack -> TiStack
 279  emptyStack' stack = stack { curDepth = 0, stkItems = [] }
 280  
 281  saveAndPush :: Addr -> TiStack -> TiDump -> (TiStack, TiDump)
 282  saveAndPush addr stack dump
 283      = (push addr stack, push stack.curDepth dump)
 284  
 285  restore :: TiStack -> TiDump -> (TiStack, TiDump)
 286  restore stack dump
 287      | isEmptyStack dump = error "restore: dump is empty"
 288      | otherwise         = case pop dump of
 289          (sp, dump') 
 290              -> ( discard (stack.curDepth - sp) stack, dump' )
 291  
 292  --
 293  ruleTable :: [(TiRuleId, String)]
 294  ruleTable 
 295      = [ (1, "Rule (2.1): Unwind a single application node onto the spine stack")
 296        , (2, "Rule (2.2): Perform a supercombinator reduction")
 297        , (3, "Rule (2.3): Update the root of redex with an indirection node pointing to the result")
 298        , (4, "Rule (2.4): Update the indirection node to immediate node")
 299        , (5, "Rule (2.5): For δ-reduction of negation primitive application with a evaluated argument")
 300        , (6, "Rule (2.6): For operand evaluation of negation")
 301        , (7, "Rule (2.7): Restore old stack when operand evaluated")
 302        , (8, "Rule (2.8): Update the application with a argument points past the indirection")
 303        , (9, "Rule (2.9): For operand evaluation of negation")
 304        , (10, "Rule (2.10): For `NPrim (PrimConstr t n)`")
 305        , (11, "Rule (2.11): For `NPrim Stop`")
 306        , (12, "Rule (2.12): For `NPrim Print` in case of head element of list evaluated")
 307        , (13, "Rule (2.13): For `NPrim Print` to evaluate head element of list")
 308        , (15, "Rule (2.15): Ex 2.21: For δ-reduction of binary operator")
 309        , (16, "Rule (2.16): Ex 2.21: For left operand evaluation of binary operator")
 310        , (17, "Rule (2.17): Ex 2.21: For rigth operand evaluation of binary operator")
 311        , (18, "Rule (2.18): Ex 2.21: For δ-reduction of conditional")
 312        , (19, "Rule (2.19): Ex 2.21: For evaluation condition of conditional")
 313        , (20, "Rule (2.20): Ex 2.22: For δ-reduction of casePair")
 314        , (21, "Rule (2.21): Ex 2.22: For evaluation of 1st arg of casePair")
 315        , (22, "Rule (2.22): Ex 2.24: For δ-reduction of caseList")
 316        , (23, "Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList")
 317        ]
 318  
 319  {-
 320  kuku :: [[Int]]
 321  kuku = [ [ i * j | j <- [1 .. 9] ] | i <- [1 .. 9] ]
 322  
 323  rjustify :: (Show a) => Int -> a -> String
 324  rjustify w = reverse . take w . (++ repeat ' ') . reverse . show 
 325  
 326  printKuku :: IO ()
 327  printKuku = putStr . unlines . map (>>= rjustify 3) $ kuku
 328  -}
 329  
 330  kukuPrint :: IO ()
 331  kukuPrint = forM_ [1 .. 9] $ \ i -> do
 332                  { forM_ [1 .. 9] $ \ j -> do
 333                      { let rep = i * j & show & reverse & (++ repeat ' ') & take 3 & reverse
 334                      ; putStr rep
 335                      }
 336                  ; putStrLn ""
 337                  }

<no location info>: warning: [-Wmissing-home-modules]
    These modules are needed for compilation but not listed in your .cabal file's other-modules: 
        Heap Iseq Language Parser Stack Utils
[7 of 7] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
Ok, 7 modules loaded.
>>> import Template.Mark5b.State
>>> kukuPrint
  1  2  3  4  5  6  7  8  9
  2  4  6  8 10 12 14 16 18
  3  6  9 12 15 18 21 24 27
  4  8 12 16 20 24 28 32 36
  5 10 15 20 25 30 35 40 45
  6 12 18 24 30 36 42 48 54
  7 14 21 28 35 42 49 56 63
  8 16 24 32 40 48 56 64 72
  9 18 27 36 45 54 63 72 81
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.1 (lib) (file src/Template/Mark5mgc/Machine.hs changed)
Preprocessing library for ifl-tut-0.2.9.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 28] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 28] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 28] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 28] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 28] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 28] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 28] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 28] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 28] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[10 of 28] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[11 of 28] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[12 of 28] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[13 of 28] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[14 of 28] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[15 of 28] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[16 of 28] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[17 of 28] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[18 of 28] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[19 of 28] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[20 of 28] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[21 of 28] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[22 of 28] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 28] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[24 of 28] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[25 of 28] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[26 of 28] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[27 of 28] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[28 of 28] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )

src/Template/Mark5mgc/Machine.hs:378:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
    |
378 | scanHeap :: TiHeap -> TiHeap
    | ^
Failed, 27 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.1 (lib) (file src/Template/Mark5mgc/Machine.hs changed)
Preprocessing library for ifl-tut-0.2.9.1..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 28] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 28] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 28] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 28] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 28] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 28] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 28] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 28] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 28] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[10 of 28] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[11 of 28] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[12 of 28] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[13 of 28] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[14 of 28] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[15 of 28] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[16 of 28] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[17 of 28] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[18 of 28] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[19 of 28] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[20 of 28] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[21 of 28] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[22 of 28] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 28] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[24 of 28] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[25 of 28] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[26 of 28] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[27 of 28] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[28 of 28] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )

src/Template/Mark5mgc/Machine.hs:373:57: error:
    • Data constructor not in scope: Marked :: Node -> Node
    • Perhaps you meant ‘NMarked’ (imported from Template.Mark5mgc.State)
    |
373 |                 (heap', as')    -> (hUpdate heap' addr (Marked (NData tag as')), addr))
    |                                                         ^^^^^^
Failed, 27 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Template.Mark5mgc.Machine
   6      where
   7  
   8  import Data.Bool
   9  import Data.Char
  10  import Data.List
  11  import Data.List.Extra
  12  
  13  import Language
  14  import Heap
  15  import Stack
  16  import Iseq
  17  import Utils
  18  
  19  import Template.Mark5mgc.State
  20  import Template.Mark5mgc.PPrint
  21  
  22  import Debug.Trace qualified as Deb
  23  
  24  debug :: Bool
  25  debug = True
  26  
  27  trace :: String -> a -> a
  28  trace | debug     = Deb.trace
  29        | otherwise = const id 
  30  
  31  traceShow :: Show a => a -> b -> b
  32  traceShow | debug     = Deb.traceShow
  33            | otherwise = const id
  34  
  35  {- * Mark 5 : Structured data -}
  36  {- | Structure of the implementations -}
  37  
  38  drive :: ([String] -> [String]) -> (String -> String)
  39  drive f = unlines . f . ("" :) . lines
  40  
  41  run :: String -> ([String] -> [String])
  42  run prog inputs
  43      = showResults 
  44      $ eval
  45      $ setControl inputs
  46      $ compile 
  47      $ parse prog
  48  
  49  setControl :: [String] -> TiState -> TiState
  50  setControl ctrl state = state { control = ctrl }
  51  
  52  {- | Compiler -}
  53  
  54  compile :: CoreProgram -> TiState
  55  compile prog = TiState
  56      { control = []
  57      , output  = []
  58      , stack   = initialStack1
  59      , dump    = initialDump
  60      , heap    = initialHeap1
  61      , globals = initialGlobals
  62      , stats   = initialStats
  63      , ruleid  = 0
  64      }
  65      where
  66          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
  67          (initialHeap, initialGlobals) = buildInitialHeap scDefs
  68          initialStack = singletonStack addressOfMain
  69          initialStack1 = singletonStack addr
  70          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
  71          addressOfPrint = aLookup initialGlobals "printList" (error "printList is not defined")
  72          (initialHeap1, addr) = hAlloc initialHeap (NAp addressOfPrint addressOfMain)
  73  
  74  extraPreludeDefs :: CoreProgram
  75  extraPreludeDefs = 
  76      [ ("False", [], EConstr 0 0)
  77      , ("True" , [], EConstr 1 0)
  78      , ("not", ["x"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  79                                (EVar "False"))
  80                           (EVar "True"))
  81      , ("and", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  82                                     (EVar "y"))
  83                                (EVar "False"))
  84      , ("or",  ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  85                                     (EVar "True"))
  86                                (EVar "y"))
  87      , ("xor", ["x", "y"], EAp (EAp (EAp (EVar "if") (EVar "x"))
  88                                     (EAp (EVar "not") (EVar "y")))
  89                                (EVar "y"))
  90      , ("MkPair", [], EConstr 0 2)
  91      , ("fst", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  92                           (EVar "K"))
  93      , ("snd", ["p"], EAp (EAp (EVar "casePair") (EVar "p"))
  94                           (EVar "K1"))
  95      , ("Nil", [], EConstr 0 0)
  96      , ("Cons", [], EConstr 1 2)
  97      , ("head", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
  98                                  (EVar "abort"))
  99                             (EVar "K"))
 100      , ("tail", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 101                                  (EVar "abort"))
 102                             (EVar "K1"))
 103      , ("printList", ["xs"], EAp (EAp (EAp (EVar "caseList") (EVar "xs"))
 104                                       (EVar "stop"))
 105                                  (EVar "printCons"))
 106      , ("printCons", ["h", "t"], EAp (EAp (EVar "print") (EVar "h"))
 107                                      (EAp (EVar "printList") (EVar "t")))
 108      ]
 109  
 110  defaultHeapSize :: Int
 111  defaultHeapSize = 1024
 112  
 113  defaultThreshold :: Int
 114  defaultThreshold = 64
 115  
 116  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 117  buildInitialHeap scDefs = (heap2, scAddrs ++ primAddrs)
 118      where
 119          (heap1, scAddrs)   = let { ?sz = defaultHeapSize; ?th = defaultThreshold }
 120                               in mapAccumL allocateSc hInitial scDefs
 121          (heap2, primAddrs) = mapAccumL allocatePrim heap1 primitives
 122  
 123  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 124  allocateSc heap scDefn = case scDefn of
 125      (name, args, body) -> (heap', (name, addr))
 126          where
 127              (heap', addr) = hAlloc heap (NSupercomb name args body)
 128  
 129  allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
 130  allocatePrim heap (name, prim) = (heap1, (name, addr))
 131      where
 132          (heap1, addr) = hAlloc heap (NPrim name prim)
 133  
 134  {- | Evaluator -}
 135  
 136  eval :: TiState -> [TiState]
 137  eval state = state : rests
 138      where
 139          rests | tiFinal state = []
 140                | otherwise      = eval $ doAdmin $ doAdminTotalSteps $ step state
 141  
 142  doAdmin :: TiState -> TiState
 143  doAdmin state = bool id gc (state.heap.curAllocs > state.heap.threshold) state
 144  
 145  step :: TiState -> TiState
 146  step state = case map toLower $ head state.control of
 147      ""                -> state' { control = tail state.control }
 148      "c"               -> state' { control = repeat "" }
 149      s | all isDigit s -> state' { control = replicate (pred $ read s) "" ++ tail state.control }
 150        | otherwise     -> state' { control = tail state.control }
 151    where
 152          state' = dispatchNode 
 153                      apStep
 154                      scStep
 155                      numStep
 156                      indStep
 157                      primStep
 158                      dataStep
 159                      (error "step: NMarked node")
 160                      (hLookup state.heap (fst (pop state.stack)))
 161                    $ state
 162  
 163  numStep :: Int -> TiState -> TiState
 164  numStep n state 
 165      | isEmptyStack state.dump = error "numStep: Number applied as a function"
 166      | otherwise = case restore state.stack state.dump of
 167          (stack1, dump1) -> setRuleId 7 $ state { stack = stack1, dump = dump1 }
 168  
 169  apStep :: Addr -> Addr -> TiState -> TiState
 170  apStep a1 a2 state = case hLookup state.heap a2 of
 171      NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
 172      _       -> setRuleId 1 $ state { stack = push a1 state.stack }
 173      where
 174          (a,_) = pop state.stack
 175  
 176  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 177  scStep name args body state
 178      | state.stack.curDepth < succ argsLen
 179          = error "scStep: too few arguments given"
 180      | otherwise
 181          = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
 182      where
 183          argsLen  = length args
 184          stack1   = discard argsLen state.stack
 185          (root,_) = pop stack1
 186          heap1    = instantiateAndUpdate body root state.heap (bindings ++ state.globals)
 187          bindings = zip args (getargs state.heap state.stack)
 188  
 189  indStep :: Addr -> TiState -> TiState
 190  indStep addr state = setRuleId 4 $ state { stack = push addr (discard 1 state.stack) }
 191  
 192  primStep :: Name -> Primitive -> TiState -> TiState
 193  primStep name prim = prim
 194  
 195  dataStep :: Tag -> [Addr] -> TiState -> TiState
 196  dataStep tag contents state = state { stack = stack1, dump = dump1 }
 197      where
 198          (stack1, dump1) = restore state.stack state.dump
 199  
 200  {- | Instantiation -}
 201  
 202  instantiate :: CoreExpr
 203              -> TiHeap
 204              -> Assoc Name Addr
 205              -> (TiHeap, Addr)
 206  instantiate expr heap env = dispatchCoreExpr
 207      (instantiateVar heap env)
 208      (instantiateNum heap env)
 209      (instantiateConstr heap env)
 210      (instantiateAp heap env)
 211      (instantiateLet heap env)
 212      (instantiateCase heap env)
 213      (instantiateLam heap env)
 214      expr
 215  
 216  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 217  instantiateVar heap env name
 218      = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 219  
 220  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 221  instantiateNum heap env num = hAlloc heap (NNum num)
 222  
 223  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 224  instantiateConstr heap env tag arity = hAlloc heap (NPrim "Constr" (primConstr tag arity))
 225  
 226  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 227  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 228      where
 229          (heap1, a1) = instantiate a heap  env
 230          (heap2, a2) = instantiate b heap1 env
 231  
 232  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 233  instantiateLet heap env isrec defs body = instantiate body heap' env'
 234      where
 235          (heap', extraBindings) = mapAccumL instantiateRhs heap defs
 236          env' = extraBindings ++ env
 237          rhsEnv | isrec     = env'
 238                 | otherwise = env
 239          instantiateRhs heap (name, rhs)
 240              = (heap1, (name, addr))
 241              where
 242                  (heap1, addr) = instantiate rhs heap rhsEnv
 243  
 244  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 245  instantiateCase heap env expr alters = error "Cannot instatiate case"
 246  
 247  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 248  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 249  
 250  instantiateAndUpdate :: CoreExpr
 251                       -> Addr
 252                       -> TiHeap
 253                       -> Assoc Name Addr
 254                       -> TiHeap
 255  instantiateAndUpdate expr updAddr heap env = dispatchCoreExpr
 256      (instUpdEVar updAddr heap env)
 257      (instUpdENum updAddr heap env)
 258      (instUpdEConstr updAddr heap env)
 259      (instUpdEAp updAddr heap env)
 260      (instUpdELet updAddr heap env)
 261      (instUpdECase updAddr heap env)
 262      (instUpdELam updAddr heap env)
 263      expr
 264  
 265  instUpdEVar :: Addr
 266              -> TiHeap
 267              -> Assoc Name Addr
 268              -> Name
 269              -> TiHeap
 270  instUpdEVar updAddr heap env v = hUpdate heap updAddr (NInd varAddr)
 271      where
 272          varAddr = aLookup env v (error ("undefined name " ++ show v))
 273  
 274  instUpdENum :: Addr
 275              -> TiHeap
 276              -> Assoc Name Addr
 277              -> Int
 278              -> TiHeap
 279  instUpdENum updAddr heap env n = hUpdate heap updAddr (NNum n)
 280  
 281  instUpdEConstr :: Addr
 282                 -> TiHeap
 283                 -> Assoc Name Addr
 284                 -> Tag
 285                 -> Arity
 286                 -> TiHeap
 287  instUpdEConstr updAddr heap env tag arity
 288      = hUpdate heap updAddr (NPrim "Constr" (primConstr tag arity))
 289  
 290  instUpdEAp :: Addr
 291             -> TiHeap
 292             -> Assoc Name Addr
 293             -> CoreExpr
 294             -> CoreExpr
 295             -> TiHeap
 296  instUpdEAp updAddr heap env e1 e2 = hUpdate heap2 updAddr (NAp a1 a2)
 297      where
 298          (heap1, a1) = instantiate e1 heap  env
 299          (heap2, a2) = instantiate e2 heap1 env
 300  
 301  instUpdELet :: Addr
 302              -> TiHeap
 303              -> Assoc Name Addr
 304              -> IsRec
 305              -> Assoc Name CoreExpr
 306              -> CoreExpr
 307              -> TiHeap
 308  instUpdELet updAddr heap env isrec defs body = instantiateAndUpdate body updAddr heap1 env1
 309      where
 310          (heap1, extraBindings) = mapAccumL instantiateRhs heap defs
 311          env1 = extraBindings ++ env
 312          rhsEnv | isrec     = env1
 313                 | otherwise = env
 314          instantiateRhs heap (name, rhs) = (heap1, (name, addr))
 315              where
 316                  (heap1, addr) = instantiate rhs heap rhsEnv
 317  
 318  instUpdECase :: Addr
 319               -> TiHeap
 320               -> Assoc Name Addr
 321               -> CoreExpr
 322               -> [CoreAlter]
 323               -> TiHeap
 324  instUpdECase updAddr heap env expr alts = error "not implemented"
 325  
 326  instUpdELam :: Addr
 327              -> TiHeap
 328              -> Assoc Name Addr
 329              -> [Name]
 330              -> CoreExpr
 331              -> TiHeap
 332  instUpdELam updAddr heap env vars body = error "not implemented"
 333  
 334  test :: String -> IO ()
 335  test = interact . drive . run 
 336  
 337  -- Gabage Collector (Mark-scan)
 338  
 339  gc :: TiState -> TiState
 340  gc state = state { heap = scanHeap $ fst
 341                          $ mapAccumL markFrom state.heap
 342                          $ findRoots state 
 343                   , stats = incGcCount state.stats
 344                   }
 345  
 346  findStackRoots :: TiStack -> [Addr]
 347  findStackRoots stack = stack.stkItems
 348  
 349  findDumpRoots :: TiDump -> [Addr]
 350  findDumpRoots dump = []
 351  
 352  findGlobalRoots :: TiGlobals -> [Addr]
 353  findGlobalRoots globals = aRange globals
 354  
 355  findRoots :: TiState -> [Addr]
 356  findRoots state = concat
 357      [ findStackRoots state.stack
 358      , findDumpRoots state.dump
 359      , findGlobalRoots state.globals
 360      ]
 361  
 362  markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
 363  markFrom heap addr = case hLookup heap addr of
 364      node -> dispatchNode 
 365              (\ addr1 addr2 -> case markFrom heap addr1 of
 366                  (heap1, addr1') -> case markFrom heap1 addr2 of
 367                      (heap2, addr2')  -> (hUpdate heap2 addr (NMarked (NAp addr1' addr2')), addr))
 368              (\ _ _ _       -> (hUpdate heap addr (NMarked node), addr)) -- NSupercomb
 369              (\ _           -> (hUpdate heap addr (NMarked node), addr)) -- NNum
 370              (\ addr1       -> markFrom heap addr1)                      -- NInd
 371              (\ _ _         -> (hUpdate heap addr (NMarked node), addr)) -- NPrim
 372              (\ tag as      -> case mapAccumL markFrom heap as of
 373                  (heap', as')    -> (hUpdate heap' addr (NMarked (NData tag as')), addr))
 374                                                                          -- NData
 375              (\ _           -> (heap, addr))                             -- NMarked
 376              node
 377  
 378  scanHeap :: TiHeap -> TiHeap
 379  scanHeap heap =foldl phi heap heap.assocs
 380      where
 381          phi h (a, node) = case node of
 382              NMarked node1 -> hUpdate h a node1
 383              _             -> hFree h a
[28 of 28] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
Ok, 28 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.1 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Configuring library for ifl-tut-0.2.9.3..
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.1: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/develop/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (ephemeral targets)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[21 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[25 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[26 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[27 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
[28 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[29 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[30 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[31 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - extra-1.7.10 (lib) (requires download & build)
 - ifl-tut-0.2.9.3 (lib) (first run)
Downloading  extra-1.7.10
Downloaded   extra-1.7.10
Starting     extra-1.7.10 (lib)
Building     extra-1.7.10 (lib)
Installing   extra-1.7.10 (lib)
Completed    extra-1.7.10 (lib)
Configuring library for ifl-tut-0.2.9.3..
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )

src/Heap.hs:28:1: error:
    The type signature for ‘hNull’ lacks an accompanying binding
   |
28 | hNull      :: Addr -- Null pointer
   | ^^^^^
Failed, 7 modules loaded.
>>> :e
   1  {-# LANGUAGE ImplicitParams #-}
   2  {-# LANGUAGE NoFieldSelectors #-}
   3  {-# LANGUAGE DuplicateRecordFields #-}
   4  {-# LANGUAGE OverloadedRecordDot #-}
   5  module Heap 
   6      where
   7  
   8  import Utils
   9  
  10  type Addr = Int
  11  
  12  {- | ヒープ
  13  -}
  14  data Heap a = Heap
  15      { maxAllocs :: Int
  16      , curAllocs :: Int
  17      , threshold :: Int
  18      , frees     :: [Addr]
  19      , assocs    :: Assoc Addr a
  20      }
  21  
  22  hInitial   :: (?sz :: Int, ?th :: Int) => Heap a 
  23  hAlloc     :: Heap a -> a -> (Heap a, Addr)
  24  hUpdate    :: Heap a -> Addr -> a -> Heap a
  25  hFree      :: Heap a -> Addr -> Heap a
  26  hLookup    :: Heap a -> Addr -> a
  27  hAddresses :: Heap a -> [Addr]
  28  hNull      :: Addr -- Null pointer
  29  
  30  hInitial = Heap 
  31      { maxAllocs = 0
  32      , curAllocs = 0
  33      , threshold = ?th
  34      , frees     = [1 .. ?sz]
  35      , assocs    = []
  36      }
  37  
  38  hAlloc heap node = case heap.frees of
  39      []   -> error "hAlloc: no space"
  40      a:rs -> (heap { maxAllocs = succ heap.maxAllocs
  41                    , curAllocs = succ heap.curAllocs
  42                    , frees     = rs
  43                    , assocs    = (a, node) : heap.assocs
  44                    }, a)
  45  
  46  hUpdate heap addr node = heap
  47      { assocs = case break ((addr ==) . fst) heap.assocs of
  48            (as, _:bs) -> (addr, node) : (as ++ bs)
  49            _          -> error "hUpdate: no entry"
  50      }
  51  
  52  hFree heap addr = heap
  53      { curAllocs = pred heap.curAllocs
  54      , frees     = addr : heap.frees
  55      , assocs    = case break ((addr ==) . fst) heap.assocs of
  56          (as,_:bs) -> as ++ bs
  57          _         -> heap.assocs
  58      }
  59  
  60  hLookup heap addr = aLookup heap.assocs addr (error "hLookup: no entry")
  61  
  62  hAddresses heap = aDomain heap.assocs
  63  
  64  hNull = 0
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:117:55: error:
    Not in scope: type constructor or class ‘Addr’
    |
117 | allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
    |                                                       ^^^^

src/Template/Mark5rvp/Machine.hs:123:64: error:
    Not in scope: type constructor or class ‘Addr’
    |
123 | allocatePrim :: TiHeap -> (Name, Primitive) -> (TiHeap, (Name, Addr))
    |                                                                ^^^^

src/Template/Mark5rvp/Machine.hs:163:11: error:
    Not in scope: type constructor or class ‘Addr’
    |
163 | apStep :: Addr -> Addr -> TiState -> TiState
    |           ^^^^

src/Template/Mark5rvp/Machine.hs:163:19: error:
    Not in scope: type constructor or class ‘Addr’
    |
163 | apStep :: Addr -> Addr -> TiState -> TiState
    |                   ^^^^

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:183:12: error:
    Not in scope: type constructor or class ‘Addr’
    |
183 | indStep :: Addr -> TiState -> TiState
    |            ^^^^

src/Template/Mark5rvp/Machine.hs:189:21: error:
    Not in scope: type constructor or class ‘Addr’
    |
189 | dataStep :: Tag -> [Addr] -> TiState -> TiState
    |                     ^^^^

src/Template/Mark5rvp/Machine.hs:198:27: error:
    Not in scope: type constructor or class ‘Addr’
    |
198 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:199:25: error:
    Not in scope: type constructor or class ‘Addr’
    |
199 |             -> (TiHeap, Addr)
    |                         ^^^^

src/Template/Mark5rvp/Machine.hs:210:40: error:
    Not in scope: type constructor or class ‘Addr’
    |
210 | instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:210:65: error:
    Not in scope: type constructor or class ‘Addr’
    |
210 | instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
    |                                                                 ^^^^

src/Template/Mark5rvp/Machine.hs:214:40: error:
    Not in scope: type constructor or class ‘Addr’
    |
214 | instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:214:64: error:
    Not in scope: type constructor or class ‘Addr’
    |
214 | instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
    |                                                                ^^^^

src/Template/Mark5rvp/Machine.hs:217:43: error:
    Not in scope: type constructor or class ‘Addr’
    |
217 | instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
    |                                           ^^^^

src/Template/Mark5rvp/Machine.hs:217:76: error:
    Not in scope: type constructor or class ‘Addr’
    |
217 | instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
    |                                                                            ^^^^

src/Template/Mark5rvp/Machine.hs:220:39: error:
    Not in scope: type constructor or class ‘Addr’
    |
220 | instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                       ^^^^

src/Template/Mark5rvp/Machine.hs:220:80: error:
    Not in scope: type constructor or class ‘Addr’
    |
220 | instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                                                                ^^^^

src/Template/Mark5rvp/Machine.hs:226:40: error:
    Not in scope: type constructor or class ‘Addr’
    |
226 | instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:226:101: error:
    Not in scope: type constructor or class ‘Addr’
    |
226 | instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
    |                                                                                                     ^^^^

src/Template/Mark5rvp/Machine.hs:238:41: error:
    Not in scope: type constructor or class ‘Addr’
    |
238 | instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
    |                                         ^^^^

src/Template/Mark5rvp/Machine.hs:238:85: error:
    Not in scope: type constructor or class ‘Addr’
    |
238 | instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
    |                                                                                     ^^^^

src/Template/Mark5rvp/Machine.hs:241:40: error:
    Not in scope: type constructor or class ‘Addr’
    |
241 | instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:241:79: error:
    Not in scope: type constructor or class ‘Addr’
    |
241 | instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
    |                                                                               ^^^^

src/Template/Mark5rvp/Machine.hs:245:25: error:
    Not in scope: type constructor or class ‘Addr’
    |
245 |                      -> Addr
    |                         ^^^^

src/Template/Mark5rvp/Machine.hs:247:36: error:
    Not in scope: type constructor or class ‘Addr’
    |
247 |                      -> Assoc Name Addr
    |                                    ^^^^

src/Template/Mark5rvp/Machine.hs:259:16: error:
    Not in scope: type constructor or class ‘Addr’
    |
259 | instUpdEVar :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:261:27: error:
    Not in scope: type constructor or class ‘Addr’
    |
261 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:268:16: error:
    Not in scope: type constructor or class ‘Addr’
    |
268 | instUpdENum :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:270:27: error:
    Not in scope: type constructor or class ‘Addr’
    |
270 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:275:19: error:
    Not in scope: type constructor or class ‘Addr’
    |
275 | instUpdEConstr :: Addr
    |                   ^^^^

src/Template/Mark5rvp/Machine.hs:277:30: error:
    Not in scope: type constructor or class ‘Addr’
    |
277 |                -> Assoc Name Addr
    |                              ^^^^

src/Template/Mark5rvp/Machine.hs:284:15: error:
    Not in scope: type constructor or class ‘Addr’
    |
284 | instUpdEAp :: Addr
    |               ^^^^

src/Template/Mark5rvp/Machine.hs:286:26: error:
    Not in scope: type constructor or class ‘Addr’
    |
286 |            -> Assoc Name Addr
    |                          ^^^^

src/Template/Mark5rvp/Machine.hs:295:16: error:
    Not in scope: type constructor or class ‘Addr’
    |
295 | instUpdELet :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:297:27: error:
    Not in scope: type constructor or class ‘Addr’
    |
297 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:312:17: error:
    Not in scope: type constructor or class ‘Addr’
    |
312 | instUpdECase :: Addr
    |                 ^^^^

src/Template/Mark5rvp/Machine.hs:314:28: error:
    Not in scope: type constructor or class ‘Addr’
    |
314 |              -> Assoc Name Addr
    |                            ^^^^

src/Template/Mark5rvp/Machine.hs:320:16: error:
    Not in scope: type constructor or class ‘Addr’
    |
320 | instUpdELam :: Addr
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:322:27: error:
    Not in scope: type constructor or class ‘Addr’
    |
322 |             -> Assoc Name Addr
    |                           ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^

src/Template/Mark5rvp/Machine.hs:341:31: error:
    Not in scope: type constructor or class ‘Addr’
    |
341 | findStackRoots :: TiStack -> [Addr]
    |                               ^^^^

src/Template/Mark5rvp/Machine.hs:344:29: error:
    Not in scope: type constructor or class ‘Addr’
    |
344 | findDumpRoots :: TiDump -> [Addr]
    |                             ^^^^

src/Template/Mark5rvp/Machine.hs:347:34: error:
    Not in scope: type constructor or class ‘Addr’
    |
347 | findGlobalRoots :: TiGlobals -> [Addr]
    |                                  ^^^^

src/Template/Mark5rvp/Machine.hs:350:26: error:
    Not in scope: type constructor or class ‘Addr’
    |
350 | findRoots :: TiState -> [Addr]
    |                          ^^^^

src/Template/Mark5rvp/Machine.hs:358:23: error:
    Not in scope: type constructor or class ‘Addr’
    |
358 | markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
    |                       ^^^^

src/Template/Mark5rvp/Machine.hs:358:40: error:
    Not in scope: type constructor or class ‘Addr’
    |
358 | markFrom :: TiHeap -> Addr -> (TiHeap, Addr)
    |                                        ^^^^

src/Template/Mark5rvp/Machine.hs:361:10: error:
    Not in scope: type constructor or class ‘Addr’
    |
361 | mark :: (Addr, Addr, TiHeap) -> (TiHeap, Addr)
    |          ^^^^

src/Template/Mark5rvp/Machine.hs:361:16: error:
    Not in scope: type constructor or class ‘Addr’
    |
361 | mark :: (Addr, Addr, TiHeap) -> (TiHeap, Addr)
    |                ^^^^

src/Template/Mark5rvp/Machine.hs:361:42: error:
    Not in scope: type constructor or class ‘Addr’
    |
361 | mark :: (Addr, Addr, TiHeap) -> (TiHeap, Addr)
    |                                          ^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:21:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:333:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:20:40: error:
    Ambiguous name ‘heap’ in import item. It could refer to:
      Template.Mark5rvp.State.GCState(heap)
      Template.Mark5rvp.State.TiState(heap)
   |
20 | import Template.Mark5rvp.State hiding (heap)
   |                                        ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )

src/Template/Mark5rvp/State.hs:333:7: error:
    parse error on input ‘TiHeap’
    |
333 |     , TiHeap   :: TiHeap
    |       ^^^^^^
Failed, 8 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:61:7: error:
    Not in scope: ‘heap’
    Perhaps you meant one of these:
      data constructor ‘Heap’ (imported from Heap),
      ‘head’ (imported from Data.List.Extra)
    Perhaps you want to remove ‘heap’ from the explicit hiding list
    in the import of ‘Template.Mark5rvp.State’
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
   |
61 |     , heap    = initialHeap1
   |       ^^^^

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Not in scope: ‘heap’
    Perhaps you meant one of these:
      data constructor ‘Heap’ (imported from Heap),
      ‘head’ (imported from Data.List.Extra)
    Perhaps you want to remove ‘heap’ from the explicit hiding list
    in the import of ‘Template.Mark5rvp.State’
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Not in scope: ‘heap’
    Perhaps you meant one of these:
      data constructor ‘Heap’ (imported from Heap),
      ‘head’ (imported from Data.List.Extra)
    Perhaps you want to remove ‘heap’ from the explicit hiding list
    in the import of ‘Template.Mark5rvp.State’
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Not in scope: ‘heap’
    Perhaps you meant one of these:
      data constructor ‘Heap’ (imported from Heap),
      ‘head’ (imported from Data.List.Extra)
    Perhaps you want to remove ‘heap’ from the explicit hiding list
    in the import of ‘Template.Mark5rvp.State’
    (src/Template/Mark5rvp/Machine.hs:20:1-44).
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:20:40: error:
    Ambiguous name ‘heap’ in import item. It could refer to:
      Template.Mark5rvp.State.GCState(heap)
      Template.Mark5rvp.State.TiState(heap)
   |
20 | import Template.Mark5rvp.State hiding (heap)
   |                                        ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:20:40: error:
    Ambiguous name ‘heap’ in import item. It could refer to:
      Template.Mark5rvp.State.GCState(heap)
      Template.Mark5rvp.State.TiState(heap)
   |
20 | import Template.Mark5rvp.State hiding (heap)
   |                                        ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:22:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:334:7-10)
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^

src/Template/Mark5rvp/Machine.hs:175:66: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:22:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:334:7-10)
    |
175 |         = doAdminScSteps $ setRuleId 3 $ state { stack = stack1, heap = heap1 }
    |                                                                  ^^^^

src/Template/Mark5rvp/Machine.hs:335:20: error:
    Ambiguous occurrence ‘heap’
    It could refer to
       either the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:22:7-10)
           or the field ‘heap’,
              imported from ‘Template.Mark5rvp.State’ at src/Template/Mark5rvp/Machine.hs:20:1-30
              (and originally defined at src/Template/Mark5rvp/State.hs:334:7-10)
    |
335 | gc state = state { heap = scanHeap $ fst
    |                    ^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:165:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
165 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:164:38: warning: [-Wambiguous-fields]
    The record update state
                        {heap = hUpdate
                                  state.heap a (NAp a1 a3)} with type TiState is ambiguous.
    This will not be supported by -XDuplicateRecordFields in future releases of GHC.
    |
164 |     NInd a3 -> setRuleId 8 $ state { heap = hUpdate state.heap a (NAp a1 a3) }
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:360:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
    |
360 | mark :: GcState -> (TiHeap, Addr)
    | ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:395:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
    |
395 | scanHeap :: TiHeap -> TiHeap
    | ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:358:28: error:
    Not in scope: data constructor ‘GcState’
    Perhaps you meant ‘TiState’ (imported from Template.Mark5rvp.State)
    |
358 | markFrom heap addr = mark (GcState { forward = addr, backward = hNull, tiHeap = heap })
    |                            ^^^^^^^

src/Template/Mark5rvp/Machine.hs:360:9: error:
    Not in scope: type constructor or class ‘GcState’
    Perhaps you meant ‘TiState’ (imported from Template.Mark5rvp.State)
    |
360 | mark :: GcState -> (TiHeap, Addr)
    |         ^^^^^^^

src/Template/Mark5rvp/Machine.hs:363:43: error:
    Not in scope: ‘forward’
    |
363 |         (\ addr1 addr2 -> mark (gcstate { forward = addr1
    |                                           ^^^^^^^

src/Template/Mark5rvp/Machine.hs:364:43: error:
    Not in scope: ‘backward’
    |
364 |                                         , backward = gcstate.forward
    |                                           ^^^^^^^^

src/Template/Mark5rvp/Machine.hs:365:43: error:
    Not in scope: ‘tiheap’
    |
365 |                                         , tiheap = hUpdate gcstate.tiheap gcstate.forward (NMarked (Visits 1) gcstate.backward)
    |                                           ^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted ) [Template.Mark5rvp.State changed]
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:358:72: error:
    Not in scope: ‘tiHeap’
    Perhaps you meant data constructor ‘Heap’ (imported from Heap)
    |
358 | markFrom heap addr = mark (GcState { forward = addr, backward = hNull, tiHeap = heap })
    |                                                                        ^^^^^^
Failed, 10 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:373:13: error:
    • The constructor ‘Done’ should have no arguments, but has been given 1
    • In the pattern: Done _
      In a case alternative:
          Done _
            -> if hLookup gcstate.tiheap gcstate.backword == hNull then
                   (gcstate.tiheap, gcstate.forward)
               else
                   mark undefined
      In the expression:
        case markstate of
          Done _
            -> if hLookup gcstate.tiheap gcstate.backword == hNull then
                   (gcstate.tiheap, gcstate.forward)
               else
                   mark undefined
    |
373 |             Done _ -> if hLookup gcstate.tiheap gcstate.backword == hNull
    |             ^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:365:111: error:
    • Couldn't match type ‘Int’ with ‘Node’
        arising from selecting the field ‘backward’
    • In the second argument of ‘NMarked’, namely ‘gcstate.backward’
      In the third argument of ‘hUpdate’, namely
        ‘(NMarked (Visits 1) gcstate.backward)’
      In the ‘tiheap’ field of a record
    |
365 |                                         , tiheap = hUpdate gcstate.tiheap gcstate.forward (NMarked (Visits 1) gcstate.backward)
    |                                                                                                               ^^^^^^^^^^^^^^^^

src/Template/Mark5rvp/Machine.hs:373:32: error:
    • Couldn't match type ‘Node’ with ‘Int’
        arising from selecting the field ‘tiheap’
    • In the first argument of ‘hLookup’, namely ‘gcstate.tiheap’
      In the first argument of ‘(==)’, namely
        ‘hLookup gcstate.tiheap gcstate.backword’
      In the expression: hLookup gcstate.tiheap gcstate.backword == hNull
    |
373 |             Done -> if hLookup gcstate.tiheap gcstate.backword == hNull
    |                                ^^^^^^^^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:366:41: error:
    parse error on input ‘}’
    |
366 |                                         }))
    |                                         ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:373:32: error:
    • Couldn't match type ‘Node’ with ‘Int’
        arising from selecting the field ‘tiheap’
    • In the first argument of ‘hLookup’, namely ‘gcstate.tiheap’
      In the first argument of ‘(==)’, namely
        ‘hLookup gcstate.tiheap gcstate.backword’
      In the expression: hLookup gcstate.tiheap gcstate.backword == hNull
    |
373 |             Done -> if hLookup gcstate.tiheap gcstate.backword == hNull
    |                                ^^^^^^^^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:376:18: error:
    parse error on input ‘->’
    |
376 |             _    -> undefined
    |                  ^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:373:24: error:
    • No instance for (GHC.Records.HasField "backword" GcState Addr)
        arising from selecting the field ‘backword’
    • In the first argument of ‘(==)’, namely ‘gcstate.backword’
      In the expression: gcstate.backword == hNull
      In the expression:
        if gcstate.backword == hNull then
            (gcstate.tiheap, gcstate.forward)
        else
            mark undefined
    |
373 |             Done -> if gcstate.backword == hNull
    |                        ^^^^^^^^^^^^^^^^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )

src/Template/Mark5rvp/Machine.hs:370:73: error:
    Variable not in scope: f :: Addr
    |
370 |         (\ name prim -> mark (gcstate { tiheap = hUpdate gcstate.tiheap f (NMarked Done (NPrim name prim))}))
    |                                                                         ^
Failed, 10 modules loaded.
>>> :e
   1  {-# LANGUAGE ImportQualifiedPost #-}
   2  {-# LANGUAGE ImplicitParams #-}
   3  {-# LANGUAGE NoFieldSelectors #-}
   4  {-# LANGUAGE DuplicateRecordFields #-}
   5  {-# LANGUAGE OverloadedRecordDot #-}
   6  module Template.Mark1
   7      where
   8  
   9  import Data.List
  10  
  11  import Language
  12  import Heap
  13  import Stack
  14  import Iseq
  15  import Utils
  16  
  17  import Debug.Trace qualified as Deb
  18  
  19  debug :: Bool
  20  debug = True
  21  
  22  trace :: String -> a -> a
  23  trace | debug     = Deb.trace
  24        | otherwise = const id 
  25  
  26  traceShow :: Show a => a -> b -> b
  27  traceShow | debug     = Deb.traceShow
  28            | otherwise = const id
  29  
  30  {- * Mark 1 : A minimal template instantiation graph reducer -}
  31  
  32  {- | Types -}
  33  
  34  data TiState
  35      = TiState
  36      { stack   :: TiStack
  37      , dump    :: TiDump
  38      , heap    :: TiHeap
  39      , globals :: TiGlobals
  40      , stats   :: TiStats
  41      , ruleid  :: TiRuleId
  42      }
  43  
  44  type TiStack   = Stack Addr
  45  
  46  type TiDump    = DummyTiDump
  47  data DummyTiDump = DummyTiDump deriving Show
  48  initialDump :: TiDump
  49  initialDump = DummyTiDump
  50  
  51  type TiHeap    = Heap Node
  52  
  53  data Node
  54      = NAp Addr Addr
  55      | NSupercomb Name [Name] CoreExpr
  56      | NNum Int
  57      deriving Show
  58  
  59  dispatchNode :: (Addr -> Addr -> a)               -- ^ NAp
  60               -> (Name -> [Name] -> CoreExpr -> a) -- ^ NSupercomb
  61               -> (Int -> a)                        -- ^ NInt
  62               -> Node -> a
  63  dispatchNode nap nsupercomb nnum node = case node of
  64      NAp a b                -> nap a b
  65      NSupercomb f args body -> nsupercomb f args body
  66      NNum n                 -> nnum n
  67  
  68  type TiGlobals = Assoc Name Addr
  69  
  70  data TiStats 
  71      = TiStats
  72      { totalSteps :: Int
  73      , scSteps    :: Int
  74      , primSteps  :: Int
  75      , deltaSteps :: Int
  76      }
  77      deriving Show
  78  
  79  initialStats :: TiStats
  80  initialStats = TiStats { totalSteps = 0, scSteps = 0, primSteps = 0, deltaSteps = 0 }
  81  
  82  incTotalSteps, incScSteps, incPrimSteps :: TiStats -> TiStats
  83  incTotalSteps stats = stats { totalSteps = succ stats.totalSteps }
  84  incScSteps    stats = stats { scSteps    = succ stats.scSteps }
  85  incPrimSteps  stats = stats { primSteps  = succ stats.primSteps }
  86  incDeltaSteps stats = stats { deltaSteps = succ stats.deltaSteps }
  87  
  88  applyToStats :: (TiStats -> TiStats) -> TiState -> TiState
  89  applyToStats f state = state { stats = f state.stats }
  90  
  91  type TiRuleId = Int
  92  
  93  setRuleId :: TiRuleId -> TiState -> TiState
  94  setRuleId r state = state { ruleid = r }
  95  
  96  {- | Structure of the implementations -}
  97  
  98  run :: String -> String
  99  run = showResults . eval . compile . parse
 100  
 101  {- | Compiler -}
 102  
 103  compile :: CoreProgram -> TiState
 104  compile prog = TiState
 105      { stack   = initialStack
 106      , dump    = initialDump
 107      , heap    = initialHeap
 108      , globals = initialGlobals
 109      , stats   = initialStats
 110      , ruleid  = 0
 111      }
 112      where
 113          scDefs = prog ++ preludeDefs ++ extraPreludeDefs
 114          (initialHeap, initialGlobals) = buildInitialHeap scDefs
 115          initialStack = singletonStack addressOfMain
 116          addressOfMain = aLookup initialGlobals "main" (error "main is not defined")
 117  
 118  extraPreludeDefs :: CoreProgram
 119  extraPreludeDefs = []
 120  
 121  defaultHeapSize :: Int
 122  defaultHeapSize = 1024
 123  
 124  defaultThreshold :: Int
 125  defaultThreshold = 50
 126  
 127  buildInitialHeap :: [CoreScDefn] -> (TiHeap, TiGlobals)
 128  buildInitialHeap = let { ?sz = defaultHeapSize; ?th = defaultThreshold } in
 129      mapAccumL allocateSc hInitial
 130  
 131  allocateSc :: TiHeap -> CoreScDefn -> (TiHeap, (Name, Addr))
 132  allocateSc heap scDefn = case scDefn of
 133      (name, args, body) -> (heap', (name, addr))
 134          where
 135              (heap', addr) = hAlloc heap (NSupercomb name args body)
 136  
 137  {- | Evaluator -}
 138  
 139  eval :: TiState -> [TiState]
 140  eval state = state : rests
 141      where
 142          rests | tiFinal state = []
 143                | otherwise      = eval $ doAdminTotalSteps $ step state
 144  
 145  tiFinal :: TiState -> Bool
 146  tiFinal state
 147      | isEmptyStack state.stack     = error "tiFinal: empty stack"
 148      | isSingletonStack state.stack = isDataNode (hLookup state.heap soleAddr)
 149      | otherwise                    = False
 150      where
 151          (soleAddr, _) = pop state.stack
 152  
 153  isDataNode :: Node -> Bool
 154  isDataNode node = case node of
 155      NNum _ -> True
 156      _      -> False
 157  
 158  doAdminTotalSteps :: TiState -> TiState
 159  doAdminTotalSteps = applyToStats incTotalSteps
 160  
 161  doAdminScSteps :: TiState -> TiState
 162  doAdminScSteps = applyToStats incScSteps
 163  
 164  doAdminPrimSteps :: TiState -> TiState
 165  doAdminPrimSteps = applyToStats incPrimSteps
 166  
 167  step :: TiState -> TiState
 168  step state = dispatchNode apStep scStep numStep (hLookup state.heap (fst (pop state.stack)))
 169             $ state
 170  
 171  numStep :: Int -> TiState -> TiState
 172  numStep n = error "numStep: Number applied as a function"
 173  
 174  apStep :: Addr -> Addr -> TiState -> TiState
 175  apStep a b state = setRuleId 1 $ state { stack = push a (state.stack :: TiStack) }
 176  
 177  scStep :: Name -> [Name] -> CoreExpr -> TiState -> TiState
 178  scStep name args body state
 179      | state.stack.curDepth < n' 
 180          = error "scStep: too few arguments given"
 181      | otherwise
 182          = doAdminScSteps $ setRuleId 2 $ state { stack = stack', heap = heap' }
 183      where
 184          stack' = push resultAddr (discard n' state.stack)
 185          (heap', resultAddr) = instantiate body state.heap env
 186          env = argBindings ++ state.globals
 187          argBindings = zip args (getargs state.heap state.stack)
 188          n' = succ (length args)
 189  
 190  getargs :: TiHeap -> TiStack -> [Addr]
 191  getargs heap stack = case pop stack of
 192      (sc, stack') -> map getarg stack'.stkItems
 193          where
 194              getarg addr = arg
 195                  where
 196                      NAp fun arg = hLookup heap addr
 197  
 198  {- | Instantiation -}
 199  
 200  instantiate :: CoreExpr
 201              -> TiHeap
 202              -> Assoc Name Addr
 203              -> (TiHeap, Addr)
 204  instantiate expr heap env = dispatchCoreExpr
 205      (instantiateVar heap env)
 206      (instantiateNum heap env)
 207      (instantiateConstr heap env)
 208      (instantiateAp heap env)
 209      (instantiateLet heap env)
 210      (instantiateCase heap env)
 211      (instantiateLam heap env)
 212      expr
 213  
 214  instantiateVar :: TiHeap -> Assoc Name Addr -> Name -> (TiHeap, Addr)
 215  instantiateVar heap env name = (heap, aLookup env name (error ("instantiateVar: Undefined name " ++ show name)))
 216  
 217  instantiateNum :: TiHeap -> Assoc Name Addr -> Int -> (TiHeap, Addr)
 218  instantiateNum heap env num = hAlloc heap (NNum num)
 219  
 220  instantiateConstr :: TiHeap -> Assoc Name Addr -> Tag -> Arity -> (TiHeap, Addr)
 221  instantiateConstr heap env tag arity = error "Cannot instantiate constructor yet"
 222  
 223  instantiateAp :: TiHeap -> Assoc Name Addr -> CoreExpr -> CoreExpr -> (TiHeap, Addr)
 224  instantiateAp heap env a b = hAlloc heap2 (NAp a1 a2)
 225      where
 226          (heap1, a1) = instantiate a heap  env
 227          (heap2, a2) = instantiate b heap1 env
 228  
 229  instantiateLet :: TiHeap -> Assoc Name Addr -> IsRec -> Assoc Name CoreExpr -> CoreExpr -> (TiHeap, Addr)
 230  instantiateLet heap env isrec bindings body = error "Cannot instatiate let(rec) yet"
 231  
 232  instantiateCase :: TiHeap -> Assoc Name Addr -> CoreExpr -> [CoreAlter] -> (TiHeap, Addr)
 233  instantiateCase heap env expr alters = error "Cannot instatiate case"
 234  
 235  instantiateLam :: TiHeap -> Assoc Name Addr -> [Name] -> CoreExpr -> (TiHeap, Addr)
 236  instantiateLam heap env vars body = error "Cannot instatiate lambda"
 237  
 238  {- | Formatting Results -}
 239  
 240  showResults :: [TiState] -> String
 241  showResults = concatMap iDisplay . iLayn' 0 . mapoid (showState, showStats)
 242  
 243  mapoid :: (a -> b, a -> b) -> [a] -> [b]
 244  mapoid (f, g) (x:xs) = case xs of
 245      [] -> f x : [g x]
 246      _  -> f x : mapoid (f,g) xs
 247  
 248  showState :: TiState -> IseqRep
 249  showState state = iConcat
 250      [ showHeap state.heap, iNewline
 251      , showStack state.heap state.stack, iNewline
 252      , showRuleId state.ruleid, iNewline
 253      ]
 254  
 255  showHeap :: TiHeap -> IseqRep
 256  showHeap heap = iConcat
 257      [ iStr "Heap ["
 258      , iIndent (iInterleave iNewline (map showHeapItem heap.assocs))
 259      , iStr " ]"
 260      ]
 261  
 262  showHeapItem :: (Addr, Node) -> IseqRep
 263  showHeapItem (addr, node) = iConcat
 264              [ showFWAddr addr, iStr ": "
 265              , showNode node
 266              ]
 267  
 268  showAddr :: Addr -> IseqRep
 269  showAddr addr = iStr ('#' : show addr)
 270  
 271  showFWAddr :: Addr -> IseqRep
 272  showFWAddr addr = iStr (rjustify 4 (show addr))
 273  
 274  showNode :: Node -> IseqRep
 275  showNode node = dispatchNode
 276      (\ a1 a2 -> iConcat [ iStr "NAp ", showAddr a1, iStr " ", showAddr a2 ])
 277      (\ name args body -> iStr ("NSupercomb " ++ name))
 278      (\ n -> iStr "NNum " `iAppend` iNum n)
 279      node
 280  
 281  showStack :: TiHeap -> TiStack -> IseqRep
 282  showStack heap stack = iConcat
 283      [ iStr "Stack ["
 284      , iIndent (iInterleave iNewline (map showStackItem stack.stkItems))
 285      , iStr " ]"
 286      ]
 287      where
 288          showStackItem addr = iConcat
 289              [ showFWAddr addr, iStr ": "
 290              , showStkNode heap (hLookup heap addr)
 291              ]
 292  
 293  showStkNode :: TiHeap -> Node -> IseqRep
 294  showStkNode heap node = dispatchNode
 295      (\ funAddr argAddr -> iConcat [ iStr "NAp ", showFWAddr funAddr
 296                                    , iStr " ", showFWAddr argAddr, iStr " ("
 297                                    , showNode (hLookup heap argAddr), iStr ")" ])
 298      (\ _ _ _ -> showNode node)
 299      (\ _ -> showNode node)
 300      node
 301  
 302  showRuleId :: TiRuleId -> IseqRep
 303  showRuleId rid = iStr ("Rule " ++ show (2, rid)) 
 304  
 305  showStats :: TiState -> IseqRep
 306  showStats state = iConcat
 307      [ iNewline, iStr "Total number of steps = "
 308      , iNum state.stats.totalSteps
 309      , iNewline, iStr "             Sc steps = "
 310      , iNum state.stats.scSteps
 311      , iNewline, iStr "           Prim steps = "
 312      , iNum state.stats.primSteps
 313      , iNewline, iStr "          Delta steps = "
 314      , iNum state.stats.deltaSteps
 315      , iNewline, iStr "     Allocation count = "
 316      , iNum state.heap.maxAllocs
 317      , iNewline, iStr "   Max depth of stack = "
 318      , iNum state.stack.maxDepth
 319      ]
 320  
 321  {- | Testing -}
 322  
 323  test :: String -> IO ()
 324  test = putStr . run
 325  
 326  {- | テスト：01 
 327  -}
 328  prog01 :: String
 329  prog01 = unlines
 330      ["main = S K K 3"]
 331  
 332  istate01 :: TiState
 333  istate01 = compile $ parse prog01
 334  
 335  iheap01 :: TiHeap
 336  iheap01 = istate01.heap
 337  
 338  iitems01 :: Assoc Addr Node
 339  iitems01 = iheap01.assocs
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
Resolving dependencies...
Build profile: -w ghc-9.2.2 -O1
In order, the following will be built (use -v for more details):
 - ifl-tut-0.2.9.3 (lib) (first run)
Preprocessing library for ifl-tut-0.2.9.3..
GHCi, version 9.2.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/nobsun/devel/ifl-tut/.ghci
[ 1 of 31] Compiling MyLib            ( src/MyLib.hs, interpreted )
[ 2 of 31] Compiling Parser           ( src/Parser.hs, interpreted )
[ 3 of 31] Compiling Stack            ( src/Stack.hs, interpreted )
[ 4 of 31] Compiling Utils            ( src/Utils.hs, interpreted )
[ 5 of 31] Compiling Iseq             ( src/Iseq.hs, interpreted )
[ 6 of 31] Compiling Language         ( src/Language.hs, interpreted )
[ 7 of 31] Compiling Template.Mark5.Primitive ( src/Template/Mark5/Primitive.hs, interpreted )
[ 8 of 31] Compiling Heap             ( src/Heap.hs, interpreted )
[ 9 of 31] Compiling Template.Mark5rvp.State ( src/Template/Mark5rvp/State.hs, interpreted )
[10 of 31] Compiling Template.Mark5rvp.PPrint ( src/Template/Mark5rvp/PPrint.hs, interpreted )
[11 of 31] Compiling Template.Mark5rvp.Machine ( src/Template/Mark5rvp/Machine.hs, interpreted )
[12 of 31] Compiling Template.Mark5mgc.State ( src/Template/Mark5mgc/State.hs, interpreted )
[13 of 31] Compiling Template.Mark5mgc.PPrint ( src/Template/Mark5mgc/PPrint.hs, interpreted )
[14 of 31] Compiling Template.Mark5mgc.Machine ( src/Template/Mark5mgc/Machine.hs, interpreted )
[15 of 31] Compiling Template.Mark5c.State ( src/Template/Mark5c/State.hs, interpreted )
[16 of 31] Compiling Template.Mark5c.PPrint ( src/Template/Mark5c/PPrint.hs, interpreted )
[17 of 31] Compiling Template.Mark5c.Machine ( src/Template/Mark5c/Machine.hs, interpreted )
[18 of 31] Compiling Template.Mark5b.State ( src/Template/Mark5b/State.hs, interpreted )
[19 of 31] Compiling Template.Mark5b.PPrint ( src/Template/Mark5b/PPrint.hs, interpreted )
[20 of 31] Compiling Template.Mark5b.Machine ( src/Template/Mark5b/Machine.hs, interpreted )
[21 of 31] Compiling Template.Mark5a.State ( src/Template/Mark5a/State.hs, interpreted )
[22 of 31] Compiling Template.Mark5a.PPrint ( src/Template/Mark5a/PPrint.hs, interpreted )
[23 of 31] Compiling Template.Mark5a.Machine ( src/Template/Mark5a/Machine.hs, interpreted )
[24 of 31] Compiling Template.Mark5.Node ( src/Template/Mark5/Node.hs, interpreted )
[25 of 31] Compiling Template.Mark5.State ( src/Template/Mark5/State.hs, interpreted )
[26 of 31] Compiling Template.Mark5.PPrint ( src/Template/Mark5/PPrint.hs, interpreted )
[27 of 31] Compiling Template.Mark5.Machine ( src/Template/Mark5/Machine.hs, interpreted )
[28 of 31] Compiling Template.Mark4   ( src/Template/Mark4.hs, interpreted )
[29 of 31] Compiling Template.Mark3   ( src/Template/Mark3.hs, interpreted )
[30 of 31] Compiling Template.Mark2   ( src/Template/Mark2.hs, interpreted )
[31 of 31] Compiling Template.Mark1   ( src/Template/Mark1.hs, interpreted )
Ok, 31 modules loaded.
>>> :q
Leaving GHCi.
