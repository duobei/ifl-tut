1187,1237c1187,1242
<   22) Heap [  49: NPrim stop
<               48: NPrim abort
<               47: NPrim caseList
<               46: NPrim casePair
<               45: NPrim if
<               44: NPrim /=
<               43: NPrim ==
<               42: NPrim >=
<               41: NPrim >
<               40: NPrim <=
<               39: NPrim <
<               38: NPrim /
<               37: NPrim *
<               36: NPrim -
<               35: NPrim negate
<               34: NSupercomb printCons
<               33: NSupercomb tail
<               32: NSupercomb head
<               31: NPrim Constr
<               30: NSupercomb snd
<               29: NSupercomb fst
<               28: NSupercomb MkPair
<               27: NSupercomb xor
<               26: NSupercomb or
<               25: NSupercomb and
<               24: NSupercomb not
<               23: NSupercomb True
<               22: NSupercomb False
<               21: NSupercomb twice
<               20: NSupercomb compose
<               19: NSupercomb S
<               18: NSupercomb K1
<               17: NSupercomb K
<               16: NSupercomb I
<               15: NSupercomb Nil
<               14: NSupercomb printList
<               13: NAp #22 #18
<               12: NPrim print
<               11: NAp #40 #2
<               10: NAp #47 #48
<                9: NNum 2
<                8: NNum 1
<                7: NPrim +
<                6: NAp #25 #49
<                5: NAp #50 #51
<                4: NAp #1 #52
<                3: NAp #1 #53
<                2: NSupercomb double
<                1: NAp #2 #3 ]
<       Stack [   1: NAp    2    3 (NAp #1 #53)
<                10: NAp   47   48 (NPrim abort) ]
---
>   22) Heap [  54: NAp #1 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #1 #54
>                1: NSupercomb double ]
>       Stack [   2: NAp    1   54 (NAp #1 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
1244,1295c1249,1305
<   23) Heap [  49: NPrim stop
<               48: NPrim abort
<               47: NPrim caseList
<               46: NPrim casePair
<               45: NPrim if
<               44: NPrim /=
<               43: NPrim ==
<               42: NPrim >=
<               41: NPrim >
<               40: NPrim <=
<               39: NPrim <
<               38: NPrim /
<               37: NPrim *
<               36: NPrim -
<               35: NPrim negate
<               34: NSupercomb printCons
<               33: NSupercomb tail
<               32: NSupercomb head
<               31: NPrim Constr
<               30: NSupercomb snd
<               29: NSupercomb fst
<               28: NSupercomb MkPair
<               27: NSupercomb xor
<               26: NSupercomb or
<               25: NSupercomb and
<               24: NSupercomb not
<               23: NSupercomb True
<               22: NSupercomb False
<               21: NSupercomb twice
<               20: NSupercomb compose
<               19: NSupercomb S
<               18: NSupercomb K1
<               17: NSupercomb K
<               16: NSupercomb I
<               15: NSupercomb Nil
<               14: NSupercomb printList
<               13: NAp #22 #18
<               12: NPrim print
<               11: NAp #40 #2
<               10: NAp #47 #48
<                9: NNum 2
<                8: NNum 1
<                7: NPrim +
<                6: NAp #25 #49
<                5: NAp #50 #51
<                4: NAp #1 #52
<                3: NAp #1 #53
<                2: NSupercomb double
<                1: NAp #2 #3 ]
<       Stack [   2: NSupercomb double
<                 1: NAp    2    3 (NAp #1 #53)
<                10: NAp   47   48 (NPrim abort) ]
---
>   23) Heap [  54: NAp #1 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #1 #54
>                1: NSupercomb double ]
>       Stack [   1: NSupercomb double
>                 2: NAp    1   54 (NAp #1 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
1302,1353c1312,1368
<   24) Heap [  50: NAp #7 #3
<               49: NPrim stop
<               48: NPrim abort
<               47: NPrim caseList
<               46: NPrim casePair
<               45: NPrim if
<               44: NPrim /=
<               43: NPrim ==
<               42: NPrim >=
<               41: NPrim >
<               40: NPrim <=
<               39: NPrim <
<               38: NPrim /
<               37: NPrim *
<               36: NPrim -
<               35: NPrim negate
<               34: NSupercomb printCons
<               33: NSupercomb tail
<               32: NSupercomb head
<               31: NPrim Constr
<               30: NSupercomb snd
<               29: NSupercomb fst
<               28: NSupercomb MkPair
<               27: NSupercomb xor
<               26: NSupercomb or
<               25: NSupercomb and
<               24: NSupercomb not
<               23: NSupercomb True
<               22: NSupercomb False
<               21: NSupercomb twice
<               20: NSupercomb compose
<               19: NSupercomb S
<               18: NSupercomb K1
<               17: NSupercomb K
<               16: NSupercomb I
<               15: NSupercomb Nil
<               14: NSupercomb printList
<               13: NAp #22 #18
<               12: NPrim print
<               11: NAp #40 #2
<               10: NAp #47 #48
<                9: NNum 2
<                8: NNum 1
<                7: NPrim +
<                6: NAp #25 #49
<                5: NAp #50 #51
<                4: NAp #1 #52
<                3: NAp #1 #53
<                2: NSupercomb double
<                1: NAp #50 #3 ]
<       Stack [   1: NAp   50    3 (NAp #1 #53)
<                10: NAp   47   48 (NPrim abort) ]
---
>   24) Heap [  55: NAp #25 #54
>               54: NAp #1 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [   2: NAp   55   54 (NAp #1 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
1360,1412c1375,1432
<   25) Heap [  50: NAp #7 #3
<               49: NPrim stop
<               48: NPrim abort
<               47: NPrim caseList
<               46: NPrim casePair
<               45: NPrim if
<               44: NPrim /=
<               43: NPrim ==
<               42: NPrim >=
<               41: NPrim >
<               40: NPrim <=
<               39: NPrim <
<               38: NPrim /
<               37: NPrim *
<               36: NPrim -
<               35: NPrim negate
<               34: NSupercomb printCons
<               33: NSupercomb tail
<               32: NSupercomb head
<               31: NPrim Constr
<               30: NSupercomb snd
<               29: NSupercomb fst
<               28: NSupercomb MkPair
<               27: NSupercomb xor
<               26: NSupercomb or
<               25: NSupercomb and
<               24: NSupercomb not
<               23: NSupercomb True
<               22: NSupercomb False
<               21: NSupercomb twice
<               20: NSupercomb compose
<               19: NSupercomb S
<               18: NSupercomb K1
<               17: NSupercomb K
<               16: NSupercomb I
<               15: NSupercomb Nil
<               14: NSupercomb printList
<               13: NAp #22 #18
<               12: NPrim print
<               11: NAp #40 #2
<               10: NAp #47 #48
<                9: NNum 2
<                8: NNum 1
<                7: NPrim +
<                6: NAp #25 #49
<                5: NAp #50 #51
<                4: NAp #1 #52
<                3: NAp #1 #53
<                2: NSupercomb double
<                1: NAp #50 #3 ]
<       Stack [  50: NAp    7    3 (NAp #1 #53)
<                 1: NAp   50    3 (NAp #1 #53)
<                10: NAp   47   48 (NPrim abort) ]
---
>   25) Heap [  55: NAp #25 #54
>               54: NAp #1 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  55: NAp   25   54 (NAp #1 #53)
>                 2: NAp   55   54 (NAp #1 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
1419,1464c1439,4515
<   26) Heap [  50: NAp #7 #3
<               49: NPrim stop
<               48: NPrim abort
<               47: NPrim caseList
<               46: NPrim casePair
<               45: NPrim if
<               44: NPrim /=
<               43: NPrim ==
<               42: NPrim >=
<               41: NPrim >
<               40: NPrim <=
<               39: NPrim <
<               38: NPrim /
<               37: NPrim *
<               36: NPrim -
<               35: NPrim negate
<               34: NSupercomb printCons
<               33: NSupercomb tail
<               32: NSupercomb head
<               31: NPrim Constr
<               30: NSupercomb snd
<               29: NSupercomb fst
<               28: NSupercomb MkPair
<               27: NSupercomb xor
<               26: NSupercomb or
<               25: NSupercomb and
<               24: NSupercomb not
<               23: NSupercomb True
<               22: NSupercomb False
<               21: NSupercomb twice
<               20: NSupercomb compose
<               19: NSupercomb S
<               18: NSupercomb K1
<               17: NSupercomb K
<               16: NSupercomb I
<               15: NSupercomb Nil
<               14: NSupercomb printList
<               13: NAp #22 #18
<               12: NPrim print
<               11: NAp #40 #2
<               10: NAp #47 #48
<                9: NNum 2
<                8: NNum 1
<                7: NPrim +
<                6: NAp #25 #49
<       
\ ファイル末尾に改行がありません
---
>   26) Heap [  55: NAp #25 #54
>               54: NAp #1 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  25: NPrim +
>                55: NAp   25   54 (NAp #1 #53)
>                 2: NAp   55   54 (NAp #1 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   27) Heap [  55: NAp #25 #54
>               54: NAp #1 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  54: NAp    1   53 (NAp #1 #52)
>                 2: NAp   55   54 (NAp #1 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 3
>       Dump [2,1]
>       Output []
>       Rule (2.16): Ex 2.21: For left operand evaluation of binary operator
>       
> 
>   28) Heap [  55: NAp #25 #54
>               54: NAp #1 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [   1: NSupercomb double
>                54: NAp    1   53 (NAp #1 #52)
>                 2: NAp   55   54 (NAp #1 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   29) Heap [  56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  54: NAp   56   53 (NAp #1 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 3
>       Dump [2,1]
>       Output []
>       Rule (2.3): Update the root of redex with an indirection node pointing to the result
>       
> 
>   30) Heap [  56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  56: NAp   25   53 (NAp #1 #52)
>                54: NAp   56   53 (NAp #1 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   31) Heap [  56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  25: NPrim +
>                56: NAp   25   53 (NAp #1 #52)
>                54: NAp   56   53 (NAp #1 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 5
>       Dump [2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   32) Heap [  56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  53: NAp    1   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #1 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [3,2,1]
>       Output []
>       Rule (2.16): Ex 2.21: For left operand evaluation of binary operator
>       
> 
>   33) Heap [  56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #1 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [   1: NSupercomb double
>                53: NAp    1   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #1 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 5
>       Dump [3,2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   34) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  53: NAp   57   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [3,2,1]
>       Output []
>       Rule (2.3): Update the root of redex with an indirection node pointing to the result
>       
> 
>   35) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  57: NAp   25   52 (NAp #50 #51)
>                53: NAp   57   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 5
>       Dump [3,2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   36) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  25: NPrim +
>                57: NAp   25   52 (NAp #50 #51)
>                53: NAp   57   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 6
>       Dump [3,2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   37) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  52: NAp   50   51 (NNum 2)
>                53: NAp   57   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 5
>       Dump [4,3,2,1]
>       Output []
>       Rule (2.16): Ex 2.21: For left operand evaluation of binary operator
>       
> 
>   38) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  50: NAp   25   49 (NNum 1)
>                52: NAp   50   51 (NNum 2)
>                53: NAp   57   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 6
>       Dump [4,3,2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   39) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NAp #50 #51
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  25: NPrim +
>                50: NAp   25   49 (NNum 1)
>                52: NAp   50   51 (NNum 2)
>                53: NAp   57   52 (NAp #50 #51)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 7
>       Dump [4,3,2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   40) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  52: NNum 3
>                53: NAp   57   52 (NNum 3)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 5
>       Dump [4,3,2,1]
>       Output []
>       Rule (2.15): Ex 2.21: For δ-reduction of binary operator
>       
> 
>   41) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  53: NAp   57   52 (NNum 3)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [3,2,1]
>       Output []
>       Rule (2.7): Restore old stack when operand evaluated
>       
> 
>   42) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  57: NAp   25   52 (NNum 3)
>                53: NAp   57   52 (NNum 3)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 5
>       Dump [3,2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   43) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NAp #57 #52
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  25: NPrim +
>                57: NAp   25   52 (NNum 3)
>                53: NAp   57   52 (NNum 3)
>                54: NAp   56   53 (NAp #57 #52)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 6
>       Dump [3,2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   44) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  53: NNum 6
>                54: NAp   56   53 (NNum 6)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [3,2,1]
>       Output []
>       Rule (2.15): Ex 2.21: For δ-reduction of binary operator
>       
> 
>   45) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  54: NAp   56   53 (NNum 6)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 3
>       Dump [2,1]
>       Output []
>       Rule (2.7): Restore old stack when operand evaluated
>       
> 
>   46) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  56: NAp   25   53 (NNum 6)
>                54: NAp   56   53 (NNum 6)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   47) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NAp #56 #53
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  25: NPrim +
>                56: NAp   25   53 (NNum 6)
>                54: NAp   56   53 (NNum 6)
>                 2: NAp   55   54 (NAp #56 #53)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 5
>       Dump [2,1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   48) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  54: NNum 12
>                 2: NAp   55   54 (NNum 12)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 3
>       Dump [2,1]
>       Output []
>       Rule (2.15): Ex 2.21: For δ-reduction of binary operator
>       
> 
>   49) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [   2: NAp   55   54 (NNum 12)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 2
>       Dump [1]
>       Output []
>       Rule (2.7): Restore old stack when operand evaluated
>       
> 
>   50) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  55: NAp   25   54 (NNum 12)
>                 2: NAp   55   54 (NNum 12)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 3
>       Dump [1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   51) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NAp #55 #54
>                1: NSupercomb double ]
>       Stack [  25: NPrim +
>                55: NAp   25   54 (NNum 12)
>                 2: NAp   55   54 (NNum 12)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 4
>       Dump [1]
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   52) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [   2: NNum 24
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 2
>       Dump [1]
>       Output []
>       Rule (2.15): Ex 2.21: For δ-reduction of binary operator
>       
> 
>   53) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  43: NAp   47   48 (NAp #22 #18) ]
>       Depth 1
>       Dump []
>       Output []
>       Rule (2.7): Restore old stack when operand evaluated
>       
> 
>   54) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  47: NAp   40    2 (NNum 24)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 2
>       Dump []
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   55) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  40: NPrim print
>                47: NAp   40    2 (NNum 24)
>                43: NAp   47   48 (NAp #22 #18) ]
>       Depth 3
>       Dump []
>       Output []
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   56) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  48: NAp   22   18 (NSupercomb Nil) ]
>       Depth 1
>       Dump []
>       Output [24]
>       Rule (2.12): For `NPrim Print` in case of head element of list evaluated
>       
> 
>   57) Heap [  57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #22 #18
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  22: NSupercomb printList
>                48: NAp   22   18 (NSupercomb Nil) ]
>       Depth 2
>       Dump []
>       Output [24]
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   58) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 1
>       Dump []
>       Output [24]
>       Rule (2.3): Update the root of redex with an indirection node pointing to the result
>       
> 
>   59) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  59: NAp   58   39 (NPrim stop)
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 2
>       Dump []
>       Output [24]
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   60) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  58: NAp   37   18 (NSupercomb Nil)
>                59: NAp   58   39 (NPrim stop)
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 3
>       Dump []
>       Output [24]
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   61) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  37: NPrim caseList
>                58: NAp   37   18 (NSupercomb Nil)
>                59: NAp   58   39 (NPrim stop)
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 4
>       Dump []
>       Output [24]
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   62) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NSupercomb Nil
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  18: NSupercomb Nil
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 2
>       Dump [1]
>       Output [24]
>       Rule (2.23): Ex 2.24: For evaluation of 1st arg of caseList
>       
> 
>   63) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NPrim Constr
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  18: NPrim Constr
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 2
>       Dump [1]
>       Output [24]
>       Rule (2.3): Update the root of redex with an indirection node pointing to the result
>       
> 
>   64) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  18: NData 0 
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 2
>       Dump [1]
>       Output [24]
>       Rule (2.10): For `NPrim (PrimConstr t n)`
>       
> 
>   65) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 1
>       Dump []
>       Output [24]
>       Rule (2.10): For `NPrim (PrimConstr t n)`
>       
> 
>   66) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  59: NAp   58   39 (NPrim stop)
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 2
>       Dump []
>       Output [24]
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   67) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  58: NAp   37   18 (NData 0 )
>                59: NAp   58   39 (NPrim stop)
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 3
>       Dump []
>       Output [24]
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   68) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NAp #59 #23
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  37: NPrim caseList
>                58: NAp   37   18 (NData 0 )
>                59: NAp   58   39 (NPrim stop)
>                48: NAp   59   23 (NSupercomb printCons) ]
>       Depth 4
>       Dump []
>       Output [24]
>       Rule (2.1): Unwind a single application node onto the spine stack
>       
> 
>   69) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NInd #39
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  48: NInd #39 ]
>       Depth 1
>       Dump []
>       Output [24]
>       Rule (2.22): Ex 2.24: For δ-reduction of caseList
>       
> 
>   70) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NInd #39
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [  39: NPrim stop ]
>       Depth 1
>       Dump []
>       Output [24]
>       Rule (2.4): Update the indirection node to immediate node
>       
> 
>   71) Heap [  59: NAp #58 #39
>               58: NAp #37 #18
>               57: NAp #25 #52
>               56: NAp #25 #53
>               55: NAp #25 #54
>               54: NNum 12
>               53: NNum 6
>               52: NNum 3
>               51: NNum 2
>               50: NAp #25 #49
>               49: NNum 1
>               48: NInd #39
>               47: NAp #40 #2
>               46: NAp #23 #2
>               45: NAp #44 #39
>               44: NAp #37 #42
>               43: NAp #47 #48
>               42: NData 1 #2 #18
>               41: NAp #19 #2
>               40: NPrim print
>               39: NPrim stop
>               38: NPrim abort
>               37: NPrim caseList
>               36: NPrim casePair
>               35: NPrim if
>               34: NPrim /=
>               33: NPrim ==
>               32: NPrim >=
>               31: NPrim >
>               30: NPrim <=
>               29: NPrim <
>               28: NPrim /
>               27: NPrim *
>               26: NPrim -
>               25: NPrim +
>               24: NPrim negate
>               23: NSupercomb printCons
>               22: NSupercomb printList
>               21: NSupercomb tail
>               20: NSupercomb head
>               19: NPrim Constr
>               18: NData 0 
>               17: NSupercomb snd
>               16: NSupercomb fst
>               15: NSupercomb MkPair
>               14: NSupercomb xor
>               13: NSupercomb or
>               12: NSupercomb and
>               11: NSupercomb not
>               10: NSupercomb True
>                9: NSupercomb False
>                8: NSupercomb twice
>                7: NSupercomb compose
>                6: NSupercomb S
>                5: NSupercomb K1
>                4: NSupercomb K
>                3: NSupercomb I
>                2: NNum 24
>                1: NSupercomb double ]
>       Stack [ ]
>       Depth 0
>       Dump []
>       Output [24]
>       Rule (2.11): For `NPrim Stop`
>       
> 
> 
> Total number of steps = 71
>              Sc steps = 9
>            Prim steps = 6
>      Allocation count = 59
>             Heap size = 59
>              GC count = 0
>    Max depth of stack = 7
> 
